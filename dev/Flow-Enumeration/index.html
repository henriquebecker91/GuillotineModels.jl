<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Flow.Enumeration · GuillotineModels.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GuillotineModels.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">GuillotineModels</a></li><li><span class="tocitem">GuillotineModels.Utilities</span><ul><li><a class="tocitem" href="../Utilities/">Utilities</a></li><li><a class="tocitem" href="../U-Args/">Utilities.Args</a></li></ul></li><li><a class="tocitem" href="../Data/">GuillotineModels.Data</a></li><li><a class="tocitem" href="../SaveModel/">GuillotineModels.SaveModel</a></li><li><span class="tocitem">GuillotineModels.CommandLine</span><ul><li><a class="tocitem" href="../CommandLine/">CommandLine</a></li><li><a class="tocitem" href="../CL-SolversArgs/">CommandLine.SolversArgs</a></li></ul></li><li><span class="tocitem">GuillotineModels.PPG2KP</span><ul><li><a class="tocitem" href="../PPG2KP/">PPG2KP</a></li><li><a class="tocitem" href="../PPG2KP-Heuristic/">PPG2KP.Heuristic</a></li><li><a class="tocitem" href="../PPG2KP-Enumeration/">PPG2KP.Enumeration</a></li></ul></li><li><span class="tocitem">GuillotineModels.Flow</span><ul><li><a class="tocitem" href="../Flow/">Flow</a></li><li class="is-active"><a class="tocitem" href>Flow.Enumeration</a></li><li><a class="tocitem" href="../Flow-Format/">Flow.Format</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">GuillotineModels.Flow</a></li><li class="is-active"><a href>Flow.Enumeration</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Flow.Enumeration</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/henriquebecker91/GuillotineModels.jl/blob/master/docs/src/Flow-Enumeration.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GuillotineModels.Flow.Enumeration"><a class="docs-heading-anchor" href="#GuillotineModels.Flow.Enumeration">GuillotineModels.Flow.Enumeration</a><a id="GuillotineModels.Flow.Enumeration-1"></a><a class="docs-heading-anchor-permalink" href="#GuillotineModels.Flow.Enumeration" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="GuillotineModels.Flow.Enumeration" href="#GuillotineModels.Flow.Enumeration"><code>GuillotineModels.Flow.Enumeration</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Collection of the methods used for generating the graph representing the flow model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/henriquebecker91/GuillotineModels.jl/blob/030b615ca6f26365e133af81469ce13d65dd4b96/src/Flow/Enumeration.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuillotineModels.Flow.Enumeration.Edge" href="#GuillotineModels.Flow.Enumeration.Edge"><code>GuillotineModels.Flow.Enumeration.Edge</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An edge of the GuillotineModels.Flow Model.</p><ul><li><p><code>indx::Any</code></p><p>Unique identifier of the edge in the model.</p></li><li><p><code>head::Any</code></p><p>The node from where the flow comes. Source.</p></li><li><p><code>tail::Any</code></p><p>The node from where the flow ends. Sink.</p></li><li><p><code>back::Any</code></p><p>The backward edge global index, if it exists, otherwise zero.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/henriquebecker91/GuillotineModels.jl/blob/030b615ca6f26365e133af81469ce13d65dd4b96/src/Flow/Enumeration.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuillotineModels.Flow.Enumeration.Node" href="#GuillotineModels.Flow.Enumeration.Node"><code>GuillotineModels.Flow.Enumeration.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A node of the GuillotineModels.Flow model.</p><ul><li><p><code>idx::Any</code></p><p>Unique identifier of the node in the model.</p></li><li><p><code>par::Any</code></p><p>The size of the plate dimension parallel to the cuts.</p></li><li><p><code>per::Any</code></p><p>The size of the plate dimension perpendicular to the cuts.</p></li><li><p><code>ori::UInt8</code></p><p>The cut orientation: one means vertical cuts; two means horizontal cuts.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/henriquebecker91/GuillotineModels.jl/blob/030b615ca6f26365e133af81469ce13d65dd4b96/src/Flow/Enumeration.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuillotineModels.Flow.Enumeration.gen_all_edges-Union{Tuple{E}, Tuple{N}, Tuple{S}, Tuple{D}, Tuple{Type{N},Type{E},Array{D,1},Array{S,1},Array{S,1},S,S}} where E where N where S where D" href="#GuillotineModels.Flow.Enumeration.gen_all_edges-Union{Tuple{E}, Tuple{N}, Tuple{S}, Tuple{D}, Tuple{Type{N},Type{E},Array{D,1},Array{S,1},Array{S,1},S,S}} where E where N where S where D"><code>GuillotineModels.Flow.Enumeration.gen_all_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gen_nodes_and_edges(N, E, d, l, w, L, W) :: ([Node], [Edge], N, E)</code></pre><p>!!! <strong>Internal use.</strong></p><p>Given the integer types used to number nodes and edges, the piece set, and the original plate length, create all nodes and edges except by some dummy ones (that are handled specially and, so, should not even be mixed here).</p><p><strong>Notes</strong></p><ul><li>This method is aware the edge identifiers <code>1</code> to <code>n+4</code> are special.</li><li>This method creates the special edges n+2 and n+4, but not any other in the <code>1:n+4</code> special identifier interval.</li></ul><p><strong>High-level procedure description</strong></p><ul><li>Compute the discretized lengths (widths).</li><li>For each discretized length (width), create a flow with max width (length).</li><li>The backward edges in not-yet-reached flow B may be referred in currently-being-built flow A (a subplate edge from A may enable more flow to a backward edge in B). To solve this problem, a structure is passed around, it is a matrix of three dimensions, which may indexed by the values that are unique for a backward edge (par<em>dim, cut</em>ori, per_dim), and stores the identifier for the unique backward edge with such attributes. If some forward edge created need to refer to a backward edge it is receives its identifier at that moment and is always referred by it, the corresponging <code>Edge</code> struct however, is only created at the final of the procedure, when all backward edges are known.</li><li>Backward Edges are similar to waste edges in the fact both of they have the <code>back</code> field as zero (they never enable another backward edge), however only backward edges have tails pointing to the source nodes of flows (and, consequently, the only ones with tails before heads).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/henriquebecker91/GuillotineModels.jl/blob/030b615ca6f26365e133af81469ce13d65dd4b96/src/Flow/Enumeration.jl#L496-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuillotineModels.Flow.Enumeration.gen_closed_flow-Union{Tuple{E}, Tuple{N}, Tuple{S}, Tuple{D}, Tuple{N,E,AbstractArray{D,2},Array{E,3},Array{D,1},Array{S,1},Array{S,1},UInt8,S,S}} where E where N where S where D" href="#GuillotineModels.Flow.Enumeration.gen_closed_flow-Union{Tuple{E}, Tuple{N}, Tuple{S}, Tuple{D}, Tuple{N,E,AbstractArray{D,2},Array{E,3},Array{D,1},Array{S,1},Array{S,1},UInt8,S,S}} where E where N where S where D"><code>GuillotineModels.Flow.Enumeration.gen_closed_flow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gen_closed_flow(...)</code></pre><p>!!! <strong>Internal use.</strong></p><p>Given some &quot;global&quot; structures/counters (<code>last_gnode_idx</code>, <code>last_gedge_idx</code>, <code>lw2pii</code>, <code>ppo2gbedge_idx</code>), the piece set (<code>d</code>, <code>par</code>, <code>per</code>) and the plate dimensions and its allowed cut orientation (<code>ori</code>, <code>PAR</code>, <code>PER</code>), this method builds the graph that represents all allowed cuts over such plate. The only changed parameter is <code>ppo2gbedge_idx</code>.</p><p><strong>Arguments</strong></p><ul><li><code>last_gnode_idx::N</code>: The highest global node identifier already in use.</li><li><code>last_gedge_idx::E</code>: The highest global edge identifier already in use.</li><li><code>lw2pii::AbstractArray{D, 2}</code>: A convenient table that translates the dimensions of a piece to the global piece code if there exists a piece that fits the description. It is not changed but a transposition of it is made frequently.</li><li><code>ppo2gbedge_idx::Array{E, 3}</code>: A table that translates the parallel-perpendicular-orientation triple to the global backward edge index, if it exists. If there is the need to refer to a circulation edge but its global identifier does not yet exists, it is created and saved to the table.</li><li><code>d::Vector{D}</code>: The demand of the pieces.</li><li><code>par::Vector{S}</code>: The size of the pieces in the dimension that is parallel to the cuts made in this flow.</li><li><code>per::Vector{S}</code>: The size of the pieces in the dimension that is perpendicular to the cuts made in this flow.</li><li><code>ori::UInt8</code>: If it is one, the flow is making vertical cuts, and therefore <code>par</code> is <code>l</code> and <code>per</code> is <code>w</code>. If it is two, the flow is making horizontal cuts and therefore <code>par</code> is <code>w</code> and <code>per</code> is <code>l</code>.</li><li><code>PAR::S</code>: The size of the flow/plate in the dimension that is parallel to the cuts made.</li><li><code>PER::S</code>: The size of the flow/plate in the dimension that is perpendicular to the cuts made.</li></ul><p><strong>Returns</strong></p><ul><li>A dense list of globalized nodes (all nodes in sequence).</li><li>A sparse list of globalized nodes (if position <code>y</code> has a corresponding node, then <code>v[y] == globalized_node_id</code>, otherwise <code>v[y] == 0</code>).</li><li>A dense list of the globalized edges.</li><li>The index of the last globalized node (after the procedure).</li><li>The index of the last globalized edge (after the procedure).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/henriquebecker91/GuillotineModels.jl/blob/030b615ca6f26365e133af81469ce13d65dd4b96/src/Flow/Enumeration.jl#L402-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuillotineModels.Flow.Enumeration.gen_rr_fow_edges!-Union{Tuple{N}, Tuple{S}, Tuple{D}, Tuple{Type{N},Array{D,1},Array{S,1},S}} where N where S where D" href="#GuillotineModels.Flow.Enumeration.gen_rr_fow_edges!-Union{Tuple{N}, Tuple{S}, Tuple{D}, Tuple{Type{N},Array{D,1},Array{S,1},S}} where N where S where D"><code>GuillotineModels.Flow.Enumeration.gen_rr_fow_edges!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gen_rr_fow_edges!(::Type{N}, d :: [D], l :: [S], L :: S) :: ([N], [(S, S)])</code></pre><p>!!! <strong>Internal use.</strong></p><p><strong>Arguments</strong></p><p>An integer type capable of representing the nodes <code>N</code>. The pieces demand <code>d</code>, their length (or width) <code>l</code>, and a plate length (or width) <code>L</code>. This method assumes the selected pieces fit the selected plate (on both dimensions, this is, in the one that was given and the one that wasn&#39;t).</p><p><strong>Return</strong></p><p>A tuple of two vectors:</p><ol><li>a vector <code>v</code> of length <code>L</code>; <code>v[y] == 1</code> iff there is a linear combination of the pieces (respecting demand) that gives <code>y</code>; otherwise <code>v[y] == 0</code>.</li><li>a vector containing all ordered pairs of linear combinations in which the difference between the two is exactly the size of a piece.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/henriquebecker91/GuillotineModels.jl/blob/030b615ca6f26365e133af81469ce13d65dd4b96/src/Flow/Enumeration.jl#L44-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuillotineModels.Flow.Enumeration.gen_u_fow_edges-Union{Tuple{E}, Tuple{N}, Tuple{S}, Tuple{Array{GuillotineModels.Flow.Enumeration.Node{S,N},1},Array{N,1},E,Array{E,3}}} where E where N where S" href="#GuillotineModels.Flow.Enumeration.gen_u_fow_edges-Union{Tuple{E}, Tuple{N}, Tuple{S}, Tuple{Array{GuillotineModels.Flow.Enumeration.Node{S,N},1},Array{N,1},E,Array{E,3}}} where E where N where S"><code>GuillotineModels.Flow.Enumeration.gen_u_fow_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gen_u_fow_edges(glo_nodes, y2node_idx, last_gedge_idx, ppo2gbedge_idx)</code></pre><p>!!! <strong>Internal use.</strong></p><p>This method generate the unrestricted subplate edges, i.e., the subplate edges representing a cut that creates a subplate in which the size of the dimension that is perpendicular to the cut is not the size of a single piece, but of a linear combination of them. Such edges are necessary to solve the unrestricted case but not to solve restricted case.</p><p><strong>Arguments</strong></p><ul><li><code>glo_nodes::Vector{Node{S, N}}</code>: A list of globalized nodes from a single graph (asserts will fail if nodes are from different graphs).</li><li><code>y2node_idx::Vector{N}</code>: A vector in which <code>!iszero(y2node_idx[y])</code> only if <code>y</code> is the <code>per</code> value of some node in <code>glo_nodes</code> and zero otherwise.</li><li><code>last_gedge_idx::E</code>: The highest global edge identifier already in use.</li><li><code>ppo2gbedge_idx::Array{E, 3}</code>: A table that translates the parallel-perpendicular-orientation triple to the global backward edge index, if it exists. If there is the need to refer to a circulation edge but its global identifier does not yet exists, it is created and saved to the table.</li></ul><p><strong>Procedure</strong></p><p>Loop through all pairs <code>i</code> and <code>j</code> (i &lt; j) of node indexes (not counting a possibly dummy sink node, but counting the source node), create a edge between the two nodes if <code>glo_nodes[j].per - glo_nodes[i].per &lt;= glo_nodes[i].per</code>.</p><p><strong>Returns</strong></p><ol><li>The list of new edges, already globalized.</li><li>The last edge index attributed.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/henriquebecker91/GuillotineModels.jl/blob/030b615ca6f26365e133af81469ce13d65dd4b96/src/Flow/Enumeration.jl#L285-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuillotineModels.Flow.Enumeration.gen_w_fow_edges-Union{Tuple{E}, Tuple{N}, Tuple{S}, Tuple{Array{GuillotineModels.Flow.Enumeration.Node{S,N},1},E}} where E where N where S" href="#GuillotineModels.Flow.Enumeration.gen_w_fow_edges-Union{Tuple{E}, Tuple{N}, Tuple{S}, Tuple{Array{GuillotineModels.Flow.Enumeration.Node{S,N},1},E}} where E where N where S"><code>GuillotineModels.Flow.Enumeration.gen_w_fow_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gen_w_fow_edges(glo_nodes, last_gedge_idx) :: ([Edge], E)</code></pre><p>!!! <strong>Internal use.</strong></p><p>Given a set of &quot;globalized&quot; nodes, and the index of the last &quot;globalized&quot; edge, create the set of corresponding waste edges (already &quot;globalized&quot;).</p><p>For now, it is not very smart and just connect the second node to the third, third to the fourth, and so on. Ideally, it should connect every node (except the first) to the next node <em>that has a backward edge associated</em> (not counting the node in question, clearly, no self-loops allowed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/henriquebecker91/GuillotineModels.jl/blob/030b615ca6f26365e133af81469ce13d65dd4b96/src/Flow/Enumeration.jl#L368-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuillotineModels.Flow.Enumeration.globalize!-Union{Tuple{E}, Tuple{N}, Tuple{S}, Tuple{D}, Tuple{Array{N,1},Array{Tuple{S,S},1},N,E,AbstractArray{D,2},Array{E,3},UInt8,S}} where E where N where S where D" href="#GuillotineModels.Flow.Enumeration.globalize!-Union{Tuple{E}, Tuple{N}, Tuple{S}, Tuple{D}, Tuple{Array{N,1},Array{Tuple{S,S},1},N,E,AbstractArray{D,2},Array{E,3},UInt8,S}} where E where N where S where D"><code>GuillotineModels.Flow.Enumeration.globalize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">globalize!(see description and source for parameters and return)</code></pre><p>!!! <strong>Internal use.</strong></p><p>The model may be seen as constituted of many independent graphs, but as there is interaction between them (i.e., subplate edges increase the flow of a backward edge in other graph) their nodes and edges must follow a global numbering and the backward edges must be known by all of graphs (as subplate edges need to refer to them as child plates).</p><p>This method takes the &quot;local/raw&quot; lists of node (<code>y2node_idx</code>) and edge (<code>raw_fow_edges</code>) numbering (that is just the normal cut positions); the index of the last globalized node (<code>last_gnode_idx</code>) and edge (<code>last_gedge_idx</code>); a matrix that gives the piece index given the piece dimensions (<code>lw2pii</code>); a tridimensional array that gives the backward edge index given its plate dimensions and allowed cut orientation (<code>ppo2gbedge_idx</code>); the allowed cut <code>ori</code>entation of the given graph; and the size of the plate dimension parallel to the allowed cuts (<code>PAR</code>).</p><p>The method return the &quot;globalized&quot; list of nodes and edges, as the index of the last globalized node and edge.</p><p>The method changes <code>ppo2gbedge_idx</code>: if a subplate (forward) edge is created and the corresponding backward edge was not yet numbered, it is given a &quot;globalized&quot; index (all backward edges are created at another step at the end).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/henriquebecker91/GuillotineModels.jl/blob/030b615ca6f26365e133af81469ce13d65dd4b96/src/Flow/Enumeration.jl#L189-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuillotineModels.Flow.Enumeration.merge_duplicates-Union{Tuple{S}, Tuple{D}, Tuple{Array{D,1},Array{S,1}}} where S where D" href="#GuillotineModels.Flow.Enumeration.merge_duplicates-Union{Tuple{S}, Tuple{D}, Tuple{Array{D,1},Array{S,1}}} where S where D"><code>GuillotineModels.Flow.Enumeration.merge_duplicates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">merge_duplicates(d :: [D], per :: [S]) :: ([D], [S])</code></pre><p>!!! <strong>Internal use.</strong></p><p>If <code>per</code> has no repeated values just return the parameters. Otherwise, for each value in <code>per</code> with duplicates, keep just one copy of such value inside <code>per</code> and delete the other copies, and the same positions in <code>d</code>; the position in <code>d</code> corresponding to the kept copy will have the sum of the <code>d</code> values for all copies deleted and the copy kept. Sort <code>per</code> by increasing value and swap positions in <code>d</code> to keep the correspondence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/henriquebecker91/GuillotineModels.jl/blob/030b615ca6f26365e133af81469ce13d65dd4b96/src/Flow/Enumeration.jl#L149-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GuillotineModels.Flow.Enumeration.reduce_dlw-Union{Tuple{S}, Tuple{D}, Tuple{Array{D,1},Array{S,1},Array{S,1},S,S}} where S where D" href="#GuillotineModels.Flow.Enumeration.reduce_dlw-Union{Tuple{S}, Tuple{D}, Tuple{Array{D,1},Array{S,1},Array{S,1},S,S}} where S where D"><code>GuillotineModels.Flow.Enumeration.reduce_dlw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reduce_dlw(d::[D], l::[S], w::[S], L::S, W::S) :: ([D], [S], [S], D)</code></pre><p>!!! <strong>Internal use.</strong></p><p>Create a copy of <code>d</code>, <code>l</code>, and <code>w</code> with only the pieces that fit the plate <code>L</code> x <code>W</code> (i.e., pieces with both dimensions smaller than the corresponding plate dimension). The last value returned is the number of pieces that pass this criteria (and, consequently, the common size of the returned vectors).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/henriquebecker91/GuillotineModels.jl/blob/030b615ca6f26365e133af81469ce13d65dd4b96/src/Flow/Enumeration.jl#L116-L125">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Flow/">« Flow</a><a class="docs-footer-nextpage" href="../Flow-Format/">Flow.Format »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 30 November 2021 21:42">Tuesday 30 November 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
