var documenterSearchIndex = {"docs":
[{"location":"PPG2KP-Heuristic/#GuillotineModels.PPG2KP.Heuristic","page":"PPG2KP.Heuristic","title":"GuillotineModels.PPG2KP.Heuristic","text":"","category":"section"},{"location":"PPG2KP-Heuristic/","page":"PPG2KP.Heuristic","title":"PPG2KP.Heuristic","text":"CurrentModule = GuillotineModels","category":"page"},{"location":"PPG2KP-Heuristic/","page":"PPG2KP.Heuristic","title":"PPG2KP.Heuristic","text":"Modules = [GuillotineModels.PPG2KP.Heuristic]","category":"page"},{"location":"PPG2KP-Heuristic/#GuillotineModels.PPG2KP.Heuristic","page":"PPG2KP.Heuristic","title":"GuillotineModels.PPG2KP.Heuristic","text":"GuillotineModels.PPG2KP.Heuristic implements the heuristic needed for faithful reimplementation of the Priced PP-G2KP from `F. Furini, E. Malaguti, and D. Thomopulos, ``Modeling Two-Dimensional Guillotine Cutting Problems via Integer Programming,'' INFORMS Journal on Computing, vol. 28, no. 4, pp. 736–751, Oct. 2016, doi: 10.1287/ijoc.2016.0710.' The heuristic itself, however, is older and described in: `M. Dolatabadi, A. Lodi, and M. Monaci, ``Exact algorithms for the two-dimensional guillotine knapsack,'' Computers \\& Operations Research, vol. 39, no. 1, pp. 48–53, Jan. 2012, doi: 10.1016/j.cor.2010.12.018.'\n\nThe methods exported by this module are not of general interest, you need to either want: (1) a fast but shelf-restricted heuristic for the guillotine 2D knapsack problem; (2) to check if they were implemented correctly; (3) to use them to make your own implementation of Priced PP-G2KP.\n\n\n\n\n\n","category":"module"},{"location":"PPG2KP-Heuristic/#GuillotineModels.PPG2KP.Heuristic.first_fit_decr-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{AbstractArray{P,1},AbstractArray{S,1},AbstractArray{S,1},AbstractArray{D,1},D,S,S}} where P where S where D","page":"PPG2KP.Heuristic","title":"GuillotineModels.PPG2KP.Heuristic.first_fit_decr","text":"first_fit_decr(p, l, w, t, n, L, W) :: (P, [D], [[D]])\n\nThe first fit width-decreasing heuristic is a deterministic, fast, and shelf-restricted heuristic for the knapsack 2D guillotine problem.\n\nThis method is mainly called by iterated_greedy and because of this the arguments are adjusted so the method is aware it is receiving a subset of the complete piece set.\n\nArguments\n\np::AbstractVector{P}: The pieces profit.\nl::AbstractVector{S}: The pieces length.\nw::AbstractVector{S}: The pieces width.\nt::AbstractVector{D}: The piecex type/index/identifier (index in the original piece set).\nn::D: The number of pieces in set (necessary to build the second returned vector).\nL::S: The original plate length.\nW::S: The original plate width.\n\nReturns\n\nThe best know value, i.e., the value of the returned solution.\nA vector v of the same size as the number of pieces; if v[i] == x then the piece i has x copies in the solution returned.\nA solution with the best known value, as the heuristic only consider shelf-restricted configurations the solution may be represented as a vector of vectors. Each vector is a length strip (with the width of the first piece inside, and the summed length of all pieces inside). Inside each vector the pieces are ordered by non-increasing width, and the vectors/stripes are sorted by non-increasing width too ( i.e., the width of their first element).\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP-Heuristic/#GuillotineModels.PPG2KP.Heuristic.iterated_greedy-Union{Tuple{I}, Tuple{P}, Tuple{S}, Tuple{D}, Tuple{AbstractArray{D,1},AbstractArray{P,1},AbstractArray{S,1},AbstractArray{S,1},S,S,Random.AbstractRNG}, Tuple{AbstractArray{D,1},AbstractArray{P,1},AbstractArray{S,1},AbstractArray{S,1},S,S,Random.AbstractRNG,I}} where I where P where S where D","page":"PPG2KP.Heuristic","title":"GuillotineModels.PPG2KP.Heuristic.iterated_greedy","text":"iterated_greedy(d, p, l, w, L, W, rng, max_iter_since_last_improv = 10^6)\n\nThe iterated greedy procedure is a heuristic that creates a random piece subset that may improve the best known value (BKV) and call the first fit with-decreasing heuristic over it (if this inner heuristic is able to position all pieces then the BKV is improved).\n\nThe first fit heuristic is deterministic and gives the same solution for a piece subset (the ordering is irrelevant), so the iterated procedure is adding diversity to it. The first fit heuristic is also shelf-restricted, so the solution is always shelf-restricted and may be impossible to reach the optimality (in the case no optimal solution is shelf-restricted).\n\nThe procedure is repeated until max_iter_since_last_improv calls to the first fit width-decreasing were made without improving the BKV.\n\nArguments\n\nd::AbstractVector{D}: The pieces demand.\np::AbstractVector{P}: The pieces profit.\nl::AbstractVector{S}: The pieces length.\nw::AbstractVector{S}: The pieces width.\nL::S: The original plate length.\nW::S: The original plate width.\nrng::AbstractRNG: The random number generator.\nmax_iter_since_last_improv::I: The parameter for the stopping criteria,\n\nafter max_iter_since_last_improv iterations since the last change in the   best known value the algorithm ends.\n\nReturns\n\nThe same of the first_fit_decr method (the iterated greedy just returns the best solution found by it).\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP-Heuristic/#GuillotineModels.PPG2KP.Heuristic.promising_kfirst-Union{Tuple{P}, Tuple{D}, Tuple{Type{D},AbstractArray{P,1},AbstractArray{P,1},P,P}} where P where D","page":"PPG2KP.Heuristic","title":"GuillotineModels.PPG2KP.Heuristic.promising_kfirst","text":"promising_kfirst(::Type{D}, p, a, bkv, A) :: D\n\n!!! Internal use.\n\nZero if there is no k for which sum(p[1:k]) > bkv && sum(a[1:k]) <= A; otherwise, return the smallest k value satisfying these conditions.\n\nIn other words, without changing the order of the given sequence, return size of the prefix of smallest size (a piece subset) that has better profit than the best known value and that it is not immediately obvious that it cannot fit the given area (does not break the naive area bound). If such prefix does not exist, then just return zero.\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP-Heuristic/#GuillotineModels.PPG2KP.Heuristic.shelves2cutpattern-Union{Tuple{S}, Tuple{D}, Tuple{Array{Array{D,1},1},Array{S,1},Array{S,1},S,S}} where S where D","page":"PPG2KP.Heuristic","title":"GuillotineModels.PPG2KP.Heuristic.shelves2cutpattern","text":"shelves2cutpattern(shelves :: [[D]], l, w, L, W) :: CutPattern{D,S}\n\nTransform the third return of iterated_greedy or first_fit_decr into a CutPattern object.\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP-Enumeration/#GuillotineModels.PPG2KP.Enumeration","page":"PPG2KP.Enumeration","title":"GuillotineModels.PPG2KP.Enumeration","text":"","category":"section"},{"location":"PPG2KP-Enumeration/","page":"PPG2KP.Enumeration","title":"PPG2KP.Enumeration","text":"CurrentModule = GuillotineModels","category":"page"},{"location":"PPG2KP-Enumeration/","page":"PPG2KP.Enumeration","title":"PPG2KP.Enumeration","text":"Modules = [GuillotineModels.PPG2KP.Enumeration]","category":"page"},{"location":"PPG2KP-Enumeration/#GuillotineModels.PPG2KP.Enumeration","page":"PPG2KP.Enumeration","title":"GuillotineModels.PPG2KP.Enumeration","text":"Collection of the methods used for generating the cuts and plates that make up the PP-G2KP model.\n\n\n\n\n\n","category":"module"},{"location":"PPG2KP-Enumeration/#GuillotineModels.PPG2KP.Enumeration.ByproductPPG2KP","page":"PPG2KP.Enumeration","title":"GuillotineModels.PPG2KP.Enumeration.ByproductPPG2KP","text":"Collection of internal datastructures used to create the PP-G2KP model and needed to assemble the solution given by the values of the model variables.\n\ncuts::Array{Tuple{P,P,P},1} where P\nIf (pp, fc, sc) is in cuts, then pp may be cut into fc and sc.\ncut_extraction::Array{D,1} where D\nIf hybridize-with-restricted, has the extracted piece for each cuts elem.\nfirst_vertical_cut_idx::Any\nEvery cut before this position is horizontal, the rest are vertical.\nnp::Array{Tuple{P,D},1} where P where D\nIf (n, p) is in np then plate n may be sold as piece p.\npli_lwb::Array{Tuple{S,S,P},1} where P where S\nIndexed by a plate index, values are the plate length, width, and bound.\nd::Array{D,1} where D\nThe demand of the pieces.\nl::Array{S,1} where S\nThe length of the pieces.\nw::Array{S,1} where S\nThe width of the pieces.\nL::Any\nThe length of the original plate.\nW::Any\nThe width of the original plate.\nmirror_plates::Bool\nIf all plates were rotated so length is never greater than width.\n\n\n\n\n\n","category":"type"},{"location":"PPG2KP-Enumeration/#GuillotineModels.PPG2KP.Enumeration.discretize-Union{Tuple{S}, Tuple{D}, Tuple{Array{D,1},Array{S,1},Array{S,1},S,S}} where S where D","page":"PPG2KP.Enumeration","title":"GuillotineModels.PPG2KP.Enumeration.discretize","text":"discretize(d::[D], l::[S], w::[S], L::S, W::S; kwargs...) :: [S]\n\n!!! Internal use.\n\nGiven the pieces demand, length, and width (d, l, w), as well the plate dimensions (L, W), return a vector of all linear combinations (constrained by demand) of the length of pieces that fit the plate (the returned vector is sorted by increasing value and no value is greater than L). To discretize the width just swap l with w and L with W.\n\nKeyword arguments\n\nAll keyword arguments are of type Bool and have false as default.\n\nonly_single_pieces: Instead of discretizing the length, return the piece lengths that exist only as the length of a piece and not as the combination of two or more smaller piece lengths.\nignore_W: Do not use W to exclude pieces that do not fit the plate.\nignore_d: Do not use demand information to discretize (consider an unlimited amount of each piece type available).\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP-Enumeration/#GuillotineModels.PPG2KP.Enumeration.filter_symm_pos-Union{Tuple{S}, Tuple{Array{S,1},S}, Tuple{Array{S,1},S,Any}} where S","page":"PPG2KP.Enumeration","title":"GuillotineModels.PPG2KP.Enumeration.filter_symm_pos","text":"filter_symm_pos(disc, dim, disc_copy = copy(disc)) -> disc_copy\n\n!!! Internal use.\n\nImplement the symmetry-breaking described in Section 2.1 of 10.1287/ijoc.2016.0710 (just after equation 10). Given a list of discretized lengths (or widths) disc and the plate length (or width) dim, return a copy of disc without all positions i in which disc[i] > div(dim/2) \\land (\\exists. disc[j] == dim - disc[i]).\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP-Enumeration/#GuillotineModels.PPG2KP.Enumeration.fits_at_least_one-Union{Tuple{S}, Tuple{D}, Tuple{GuillotineModels.Utilities.SortedLinkedLW{D,S},S,S}} where S where D","page":"PPG2KP.Enumeration","title":"GuillotineModels.PPG2KP.Enumeration.fits_at_least_one","text":"fits_at_least_one(sllw, L, W) :: Bool\n\n!!! Internal use.\n\nTrue if at least one piece in sllw fits inside a LxW plate; false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP-Enumeration/#GuillotineModels.PPG2KP.Enumeration.gen_cuts-Union{Tuple{M}, Tuple{P}, Tuple{S}, Tuple{D}, Tuple{Type{P},Array{D,1},GuillotineModels.Utilities.SortedLinkedLW{D,S},S,S}, Tuple{Type{P},Array{D,1},GuillotineModels.Utilities.SortedLinkedLW{D,S},S,S,Val{M}}} where M where P where S where D","page":"PPG2KP.Enumeration","title":"GuillotineModels.PPG2KP.Enumeration.gen_cuts","text":"gen_cuts(::Type{P}, d, sllw, L, W; [kwargs])\n\n!!! Internal use.\n\nThe main method responsible for generating all the cuts used to create both the original PP-G2KP model as its enhanced version (in this case, it generates the piece extractions too).\n\nArguments\n\nPositional and required arguments\n\n::Type{P}: The type of the piece profits (and area).\nd::Vector{D}: The pieces demand.\nsllw::SortedLinkedLW{D, S}: The SortedLinkedLW containing the length and width of the pieces.\nL::S: The plate length.\nW::S: The plate width.\n\nKeyword arguments\n\nAll keyword arguments are of type Bool.\n\nignore_2th_dim: Default: false. Ignore the dimension not being discretized during discretization.\nignore_d: Default: false. Ignore the demand information during discretization.\nround2disc: Default: true. Round the size of the second child of a cut to a discretized position.\nfaithful2furini2016: Default: false. Tries to be the most faithful possible to the description in 10.1287/ijoc.2016.0710.\nno_redundant_cut: Default: false. Disables the Redundant-Cut reduction described in 10.1287/ijoc.2016.0710.\nno_cut_position: Default: false. Disables the Cut-Position reduction described in 10.1287/ijoc.2016.0710.\nno_furini_symmbreak: Default: false. Ignored if faithful2furini2016 is false. Disables the symmetry-breaking used in 10.1287/ijoc.2016.0710 (consequently all discretized positions are used, none is removed).\n\nReturn\n\nThe return is a ByproductPPG2KP object.\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP-Enumeration/#GuillotineModels.PPG2KP.Enumeration.no_chance_to_fit_6_piece-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{Array{D,1},Array{S,1},Array{S,1},Array{P,1},S,S,P}} where P where S where D","page":"PPG2KP.Enumeration","title":"GuillotineModels.PPG2KP.Enumeration.no_chance_to_fit_6_piece","text":"no_chance_to_fit_6_piece(d, l, w, a, L, W, A; ignore_2th_dim = false)\n\nReturns true if it is demonstrably impossible to fit six pieces into the plate; and false if there is some possibility (but no guarantee) of fitting six pieces in the plate.\n\nIf ignore_2th_dim is true, w and W are ignored by the algorithm.\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP-Enumeration/#GuillotineModels.PPG2KP.Enumeration.reduce2fit_usl-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{Array{S,1},Array{D,1},Array{S,1},S,S}} where P where S where D","page":"PPG2KP.Enumeration","title":"GuillotineModels.PPG2KP.Enumeration.reduce2fit_usl","text":"reduce2fit_usl(sl, sli2pii, w, L, W) :: [S]\n\n!!! Internal use.\n\nGiven a plate (L, W), and the pieces sorted by length (sl, sli2pii, w), return an increasing vector of unique lengths that pertain to a piece that fits the plate. If two or more pieces share length and fit the plate, only one copy of that length is included in the returned vector.\n\nArguments\n\nsl::Vector{S}: The piece lengths sorted by increase-or-stay order.\nsli2pii::Vector{D}: If sli2pii[i] == j then sl[i] and w[j] correspond to the same item.\nw::Vector{S}: The piece widths (in 'original' order).\nL::S: The length of the plate.\nW::S: The width of the plate.\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP-Enumeration/#GuillotineModels.PPG2KP.Enumeration.reflect!-Tuple{Any,Any}","page":"PPG2KP.Enumeration","title":"GuillotineModels.PPG2KP.Enumeration.reflect!","text":"reflect!(l, L)\n\n!!! Internal use.\n\nChange l to the sorted union of [li ∈ l ∧ li ≤ L÷2 | li] and `[li ∈ l ∧ li\n\nL÷2 ∧ li < L | L - li]; assumesl` is in increase-or-stay order.\n\nThe new value of l has an important property that: any pair of plates generated by a cut using the original l will also be generated by some cut in the modified set, even with the modified set only having cuts in the first half of the plate. Note any values equal to or above L are discarded.\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP-Enumeration/#GuillotineModels.PPG2KP.Enumeration.should_extract_piece_from_plate-Union{Tuple{S}, Tuple{D}, Tuple{D,S,S,GuillotineModels.Utilities.SortedLinkedLW{D,S}}, Tuple{D,S,S,GuillotineModels.Utilities.SortedLinkedLW{D,S},UInt8}} where S where D","page":"PPG2KP.Enumeration","title":"GuillotineModels.PPG2KP.Enumeration.should_extract_piece_from_plate","text":"should_extract_piece_from_plate(pii, L, W, sllw, symm = 0x03) :: Bool\n\n!!! Internal use.\n\nConsidering the enhanced PP-G2KP model, it is necessary to known if there will be an 'extraction' variable representing the extraction of piece with index pii from a plate with length L and width L.\n\nA piece should be extracted from a plate if:\n\nThe piece fits inside the plate.\nIt is not possible to extract the piece in consideration together with any other piece (even other copy of the same piece) from the plate in consideration (for the cut orientations allowed by symm which by default are both vertical and horizontal).\n\nArguments\n\npii::D: The index of the piece.\nL::S: The length of the plate.\nW::S: The width of the plate.\nsllw::SortedLinkedLW{D, S}: The SortedLinkedLW struct for the pieces.\nsymm::UInt8 = 0x03: which cut orientations are allowed: 0x01 means 'allow only horizontal cuts', 0x02 means 'allow only vertical cuts', and 0x03 means 'allow both kinds of cuts'.\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP-Enumeration/#GuillotineModels.PPG2KP.Enumeration.ub_num_pieces_fit-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{Array{D,1},Array{S,1},Array{S,1},Array{P,1},S,S,P,D}} where P where S where D","page":"PPG2KP.Enumeration","title":"GuillotineModels.PPG2KP.Enumeration.ub_num_pieces_fit","text":"ub_num_pieces_fit(d, l, w, a, L, W, A, cutoff; ignore_2th_dim = false)\n\n!!! Internal use.\n\nGiven a piece set (defined by demand, length, width, and area), and a plate (defined by Length, Width, and Area), returns the min between cutoff and an upper bound on the number of pieces that fit inside the plate. If ignore_2th_dim is true, do not use w and W to filter pieces that do not even fit the plate when alone.\n\nIn other words, ub_num_pieces_fit(..., 6) will return 6 if it is possible (but not guaranteed) for 6 or more pieces to fit in the plate, and will return x if x < 6 is the greatest number of pieces that have yet some possibility of being packed together; x + 1 is already guaranteed to be impossible.\n\n\n\n\n\n","category":"method"},{"location":"CL-SolversArgs/#GuillotineModels.CommandLine.SolversArgs","page":"CommandLine.SolversArgs","title":"GuillotineModels.CommandLine.SolversArgs","text":"","category":"section"},{"location":"CL-SolversArgs/","page":"CommandLine.SolversArgs","title":"CommandLine.SolversArgs","text":"CurrentModule = GuillotineModels","category":"page"},{"location":"CL-SolversArgs/","page":"CommandLine.SolversArgs","title":"CommandLine.SolversArgs","text":"Modules = [GuillotineModels.CommandLine.SolversArgs]","category":"page"},{"location":"CL-SolversArgs/#GuillotineModels.CommandLine.SolversArgs","page":"CommandLine.SolversArgs","title":"GuillotineModels.CommandLine.SolversArgs","text":"SolversArgs module aggregates the methods necessary for making solvers available to use with GuillotineModels.CommandLine methods (especially run).\n\nThe package Requires.jl is used to implement GuillotineModels.SolversArgs.empty_configured_model(Val(:SOME_SOLVER)) only if SOME_SOLVER package is loaded.\n\nThe solver-specific methods this module implements for each supported solver are: GuillotineModels.Utilities.Args.{accepted_arg_list, throw_if_incompatible_options}, and GuillotineModels.CommandLine.SolversArgs. empty_configured_model. The GuillotineModels.Utilities methods are always available, not just when the respective solver package was imported.\n\nThe supported solvers are CPLEX, Gurobi, Cbc, and GLPK. Supporting new solvers is just a question of implementing a specialization of the three methods mentioned above for the specific solver (see the code for examples).\n\n\n\n\n\n","category":"module"},{"location":"CL-SolversArgs/#GuillotineModels.CommandLine.SolversArgs.empty_configured_model-Union{Tuple{T}, Tuple{Val{T},Any}} where T","page":"CommandLine.SolversArgs","title":"GuillotineModels.CommandLine.SolversArgs.empty_configured_model","text":"empty_configured_model(::Val{T}, p_args) :: JuMP-like Model\n\nCreates an empty (no variables or constraints) and configured (p_args is used to set the parameters of an attached solver) model of the solver ::Val{T} (for example, passing ::Val{:CPLEX} will call the specialized method for CPLEX solver).\n\nThe options available for p_args are available in GuillotineModels. Utilities.Args.accepted_arg_list(::Val{SOLVER_PACKAGE_SYMBOL}).\n\n\n\n\n\n","category":"method"},{"location":"Flow-Format/#GuillotineModels.Flow.Format","page":"Flow.Format","title":"GuillotineModels.Flow.Format","text":"","category":"section"},{"location":"Flow-Format/","page":"Flow.Format","title":"Flow.Format","text":"CurrentModule = GuillotineModels","category":"page"},{"location":"Flow-Format/","page":"Flow.Format","title":"Flow.Format","text":"Modules = [GuillotineModels.Flow.Format]","category":"page"},{"location":"Flow-Format/#GuillotineModels.Flow.Format","page":"Flow.Format","title":"GuillotineModels.Flow.Format","text":"Flow.Format consists uniquely of optional methods for making it easier to visualize the structure of the Flow model. It requires the user to install and import packages not in the GuillotineModels dependencies in order to have access to its methods. The flow2digraph method needs LightGraphs, and the other three (flow2file, flow2tikzpic, flow2pdf) need LightGraphs, TikzGraphs, and TikzGraphs.\n\nThe methods signatures are:\n\nflow2digraph(num_nodes, edges) :: LightGraphs.SimpleDiGraph\nflow2tikzpic(nodes, edges) :: TikzPictures.TikzPicture\nfunction flow2file(nodes, edges, out :: TikzPictures.SaveType) :: Nothing\nfunction flow2pdf(nodes, edges, fname) :: Nothing\n\nThe Node and Edge types are defined by Flow.Enumeration and the Vectors of all nodes and all edges of the model are returned by GuillotineModels.build_model(::Val{:Flow}, ...).\n\n\n\n\n\n","category":"module"},{"location":"Flow/#GuillotineModels.Flow","page":"Flow","title":"GuillotineModels.Flow","text":"","category":"section"},{"location":"Flow/","page":"Flow","title":"Flow","text":"CurrentModule = GuillotineModels","category":"page"},{"location":"Flow/","page":"Flow","title":"Flow","text":"Modules = [GuillotineModels.Flow]","category":"page"},{"location":"Flow/#GuillotineModels.build_model-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{Val{:Flow},Any,Array{D,1},Array{P,1},Array{S,1},Array{S,1},S,S}, Tuple{Val{:Flow},Any,Array{D,1},Array{P,1},Array{S,1},Array{S,1},S,S,Dict{String,Any}}} where P where S where D","page":"Flow","title":"GuillotineModels.build_model","text":"build_model(::Val{:Flow}, model, d, p, l, w, L, W, [options])\n\nThe Flow model is a variant of the PPG2KP model using flow constraints. The result is a considerably larger model with a slight enhancement on the relaxation bound.\n\nArguments\n\nThe required arguments are the same as all build_model methods, and the optional argument options is always ignored.\n\nHigh-Level Model Description\n\nBoth length and width of the original plate may be seen as line segments. From these line segments, let us just consider a subset of the points: the first point (zero), the last point (L or W), and the ones in the middle that match a normal cut position.\n\nFor each width cut position, there is an instance of the length point set representing plates with all possible lengths but with a fixed width. The analogue (each length cut position ... width point set) also exists. Each of these point set instances is the vertex set of a strongly connected directed graph. There are no edges connecting one of such graphs with another (they interact by special constrainsts that cannot be seen as 'flow constraints'/edges).\n\nThe variables of the model are the edges between those graphs. The edges are may be divided into forward edges and backward/circulation edges. The forward edges go from a node representing a point closer to the start of the line segment to a node representing a point farther from the start. The backward/circulation edges always go from a non-first (non-zero) point to the first/zero point of the graph. The forward edges represent cutting part of the plate for use or trimming. The backard edges represent the availibity of a plate of some dimensions to be cut in some orientation. For example, if there are two units of flow flowing through a forward edge that goes from point length 15 to point length 35 of the set with fixed width 50, then there are at least two plates of width 50 that have a subplate of length 20 (and width 50) cut from two parallel cuts, one in position 15 and another in 35. The two parent plates may have the same dimensions (i.e., their length is also equal to each other), or they may have different total length (they only share the same width); for an example, one of them may stop at length 35 and the other may have length 1000. Considering this same example, if there are a plate of size 35x50 and another of size 1000x50 available, then there is one of flow in the backward edge from point length 35 to point zero and from point length 1000 to point zero (all inside the set with fixed width 50).\n\nFinally, forward edges may be subdivided into waste edges, piece edges and subplate edges. Waste edges do nothing besides letting the flow pass through them. The variables representing piece edges are in the objective function with coefficient equal to the profit of the corresponding piece. Subplate edges \"introduce\" new flow in the system, they do not only allow the flow to pass through them but also increase the flow in a correspondent circulation edge of the (other) graph that represents the plate they are extracting, but to be cut in the opposite orientation. For example, an increase in the flow of the subplate edge from length 50 to length 150 of the set with fixed width 200 will increase by the same amount the flow of the backward edge from width 200 to width zero of the set with fixed length 100.\n\nThe number and dimension of the original plates available is given by all backward edges that have their value fixed to a non-zero value a priori.\n\nSlightly Misleading Low-Level Explanation\n\nVariables\n\nedge[i]: Positive Integer. The only variable. Measures the amount of flow passing through the edge. Has all edges indexed by their globalized index. Uses the many reverse indexes created by the enumeration process to build the model.\n\nObjective function:\n\nMaximize the profit of the pieces cut.\n\nsum(p[CP] * edge[1:number_of_pieces])\n\nConstraints\n\nThere is exactly one of the original plate, so its circulation arc is available since start, and cannot ever go over one. It must be one.\nsum(edge[is the backward edge of the original plate]) == 1\nThe flow must go round.\nsum(edge[all edges ending in node x]) == sum(edge[all edges starting at node x]) : for every node x\nIf you cut a subplate anywhere then you allow its flow to circle again.\nsum(edge[a backward edge]) <= sum(edge[a forward edge that cuts the subplate corresponging to that backward edge]) : for each backward edges\nThe number of pieces of some type is always less than or equal to its demand.\nedge[i] <= d[i] : for each i in 1:number_of_pieces\n\nDummy Plate Identifiers:\n\n0 - No plate. Waste and backward edges use this value in the back field.\n1:n - A dummy edge corresponding to a piece index, used in the objective function. Edges cutting pieces do not actually appear in the objective function but, in fact, allow more flow to pass through by some of these dummy piece edges.\nn+1 - A dummy edge that is upper bounded at one and allows one extra flow to the original plate default cutting (vertical) backward edge (i.e., n+2). Necessary to avoid n+2 to be restricted by a possible edge that cuts the whole original plate alternative cutting (horizontal). In other words, without this, if a piece has the same length as the plate, then the model has a deadlock problem, and will give a zero objective problem.\nn+2 - The original plate default cutting (vertical) backward edge.\nn+3 - The original plate vertical forward edge that takes the whole plate and allows it to be horizontally cut (i.e., allow flow to n+2).\nn+4 - The original plate alternative cutting (horizontal) backward edge. It is allowed by cutting n+2.\nn+5:m - The remaining intermediary plates.\n\n\n\n\n\n","category":"method"},{"location":"U-Args/#GuillotineModels.Utilities.Args","page":"Utilities.Args","title":"GuillotineModels.Utilities.Args","text":"","category":"section"},{"location":"U-Args/","page":"Utilities.Args","title":"Utilities.Args","text":"CurrentModule = GuillotineModels","category":"page"},{"location":"U-Args/","page":"Utilities.Args","title":"Utilities.Args","text":"Modules = [GuillotineModels.Utilities.Args]","category":"page"},{"location":"U-Args/#GuillotineModels.Utilities.Args","page":"Utilities.Args","title":"GuillotineModels.Utilities.Args","text":"Submodule of Utilities that groups the utilities related to command-line parsing.\n\n\n\n\n\n","category":"module"},{"location":"U-Args/#GuillotineModels.Utilities.Args.Arg","page":"Utilities.Args","title":"GuillotineModels.Utilities.Args.Arg","text":"An argument with name, default value, and help message.\n\nname::String\nThe name with no initial double dashes but with dashes instead of spaces.\ndefault::Any\nThe default value if the argument is not specified. Use false for flags.\nhelp::String\nThe help message to be displayed about this argument.\n\n\n\n\n\n","category":"type"},{"location":"U-Args/#ArgParse.add_arg_table!-Tuple{ArgParse.ArgParseSettings,GuillotineModels.Utilities.Args.Arg}","page":"Utilities.Args","title":"ArgParse.add_arg_table!","text":"ArgParse.add_arg_table!(settings :: ArgParseSettings, arg :: Arg)\n\nA specialization of ArgParse.add_arg_table! to transform Arg objects into options of ArgParseSettings. Boolean arguments become :store_{true|false} options (depending on the default) and non-boolean arguments become :store_arg options with a default (and enforcing the same arg_type of the default).\n\n\n\n\n\n","category":"method"},{"location":"U-Args/#GuillotineModels.Utilities.Args.accepted_arg_list-Union{Tuple{Val{T}}, Tuple{T}} where T","page":"Utilities.Args","title":"GuillotineModels.Utilities.Args.accepted_arg_list","text":"accepted_arg_list(::Val{T}) :: Vector{Arg} where {T}\n\nGeneric error fallback. Any model or solver to be supported by GuillotineModules.SolversArgs.run should implement their own version of this method (replacing the T in ::Val{T} by a Symbol identifying the solver package or the name of the model). Look at module SolversArgs source for examples of the implementation for a solver, and at PPG2KP module source for examples for a model.\n\nGives the list of accepted options by some model or solver. The options have either a boolean default (in this case they take no argument, the presence of the option just flips the default value) or a non-boolean default (in this case, if they are passed in the command-line, they must have a parameter; if they are not passed, the default value is used).  Every solver implementation must support the no-output and preferably the raw-argument option too. The name of the supported solvers and implemented methods need to be passed to the run method for them to be considered by it.\n\n\n\n\n\n","category":"method"},{"location":"U-Args/#GuillotineModels.Utilities.Args.create_normalized_arg_subset-Tuple{Any,Array{GuillotineModels.Utilities.Args.Arg,1}}","page":"Utilities.Args","title":"GuillotineModels.Utilities.Args.create_normalized_arg_subset","text":"create_normalized_arg_subset(p_args, selected :: Vector{Arg})\n\nCreate a new Dict with keys equal to selected names and values equal to selected defaults, except that if p_args has a key with the same name as an argument then the value in p_args is used instead the default.\n\nIt shows an warning for every key in p_args that is not a name in selected.\n\nIf a quiet flag is recognized by selected and is true (either by explicit definition or by default), then the warnings are not printed.\n\n\n\n\n\n","category":"method"},{"location":"U-Args/#GuillotineModels.Utilities.Args.throw_if_incompatible_options-Union{Tuple{T}, Tuple{Val{T},Any}} where T","page":"Utilities.Args","title":"GuillotineModels.Utilities.Args.throw_if_incompatible_options","text":"throw_if_incompatible_options(::Val{T}, p_args) where {T}\n\nGeneric error fallback. Any model or solver to be supported by GuillotineModels.SolversArgs.run should implement their own version of this method (replacing the T in ::Val{T} by a Symbol identifying the solver package or the name of the model). Look at module SolversArgs source for examples of the implementation for a solver, and at PPG2KP module source for examples for a model. Every solver implementation must support the no-output option, and there is no need to guarantee that conflicts with involving the raw-argument option are detected.\n\nOften is specialized to an empty method, as is not so often that solvers or models have conflicting options.\n\n\n\n\n\n","category":"method"},{"location":"CommandLine/#GuillotineModels.CommandLine","page":"CommandLine","title":"GuillotineModels.CommandLine","text":"","category":"section"},{"location":"CommandLine/","page":"CommandLine","title":"CommandLine","text":"CurrentModule = GuillotineModels","category":"page"},{"location":"CommandLine/","page":"CommandLine","title":"CommandLine","text":"Modules = [GuillotineModels.CommandLine]","category":"page"},{"location":"CommandLine/#GuillotineModels.CommandLine.argparse_settings-Tuple{Array{Symbol,1},Array{Symbol,1}}","page":"CommandLine","title":"GuillotineModels.CommandLine.argparse_settings","text":"argparse_settings(models_list, solvers_list) :: ArgParseSettings\n\n!!! Internal use.\n\nCreate an ArgParseSettings which includes the core arguments, generic arguments, and all arguments from models and solvers available (prefixed by their model or solver name).\n\nOptions of all models and solvers are added even if just one model is selected at a time. The reasons for this are: (1) we do not know the model before the parsing unless we manipulate ARGS directly; (2) if the unused solvers and models are not included in the ArgParseSettings they do not appear in the help message.\n\n\n\n\n\n","category":"method"},{"location":"CommandLine/#GuillotineModels.CommandLine.core_argparse_settings-Tuple{}","page":"CommandLine","title":"GuillotineModels.CommandLine.core_argparse_settings","text":"core_argparse_settings() :: ArgParseSettings\n\n!!! Internal use.\n\nAn ArgParseSettings with the three core positional arguments model, solver, and instance_path. They cannot be modeled as Arg objects because, by design, all extra arguments must be options (i.e., be optional and preceded by dashes).\n\n\n\n\n\n","category":"method"},{"location":"CommandLine/#GuillotineModels.CommandLine.create_unprefixed_subset-Union{Tuple{T}, Tuple{Any,T}} where T","page":"CommandLine","title":"GuillotineModels.CommandLine.create_unprefixed_subset","text":"create_unprefixed_subset(prefix, p_args :: T) :: T\n\n!!! Internal use.\n\nGiven some prefix, query the accepted_arg_list(Val{Symbol(prefix)}), to know which arguments were prefixed this way, search for them (with the prefix) in p_args and return a new typeof(p_args) object in which there is only the searched key-value pairs but the keys are changed to not have the prefix anymore.\n\n\n\n\n\n","category":"method"},{"location":"CommandLine/#GuillotineModels.CommandLine.gen_prefixed_argparse_settings-Tuple{Union{String, Symbol}}","page":"CommandLine","title":"GuillotineModels.CommandLine.gen_prefixed_argparse_settings","text":"gen_prefixed_argparse_settings(solver_or_model_name) :: ArgParseSettings\n\n!!! Internal use.\n\nBuilds and returns an ArgParseSettings object representing all options of the given solver or model already prefixed with its name.\n\nThe solver_or_model_name may be a Symbol or String (none is prefered), and the method works because the solver or model implements accepted_arg_list(Val{Symbol(solver_or_model_name)})\n\n\n\n\n\n","category":"method"},{"location":"CommandLine/#GuillotineModels.CommandLine.generic_argparse_settings-Tuple{}","page":"CommandLine","title":"GuillotineModels.CommandLine.generic_argparse_settings","text":"generic_argparse_settings() :: ArgParseSettings\n\n!!! Internal use.\n\nAn ArgParseSettings containing all options (not positional arguments) that are independent from the chosen solver or model.\n\n\n\n\n\n","category":"method"},{"location":"CommandLine/#GuillotineModels.CommandLine.generic_args-Tuple{}","page":"CommandLine","title":"GuillotineModels.CommandLine.generic_args","text":"generic_args() :: Vector{Arg}\n\n!!! Internal use.\n\nAll the Args representing options that are independent from solver or model.\n\n\n\n\n\n","category":"method"},{"location":"CommandLine/#GuillotineModels.CommandLine.parse_args-Tuple{Any,Any,Any}","page":"CommandLine","title":"GuillotineModels.CommandLine.parse_args","text":"parse_args(args, models_list, solvers_list) :: Dict{String, Any}\n\n!!! Internal use.\n\nGiven a vector of the command-line arguments args and the lists of available models and solvers, parse the arguments. If the args refer to a model or solver not in models_list or solvers_list exceptions may be thrown. If args just triggers the help message, an empty Dict is returned.\n\n\n\n\n\n","category":"method"},{"location":"CommandLine/#GuillotineModels.CommandLine.read_build_solve_and_print-Tuple{Any,Any}","page":"CommandLine","title":"GuillotineModels.CommandLine.read_build_solve_and_print","text":"read_build_solve_and_print(problem, format, pp)\n\n!!! Internal use.\n\nGiven the parsed parameters (pp), read the instance file, build the model, solve the model (unless pp['do-not-solve'] is true), and print statistics related to this process (unless pp['no-csv-output'] is true). The list of options recognized and implemented by this method is the list returned by generic_args() (it also needs the required arguments in core_argparse_settings()). The other arguments are solver or model specific and are extracted and passed to their specific methods.\n\n\n\n\n\n","category":"method"},{"location":"CommandLine/#GuillotineModels.CommandLine.round_instance-Tuple{Any,Any}","page":"CommandLine","title":"GuillotineModels.CommandLine.round_instance","text":"round_instance(instance, p_args) -> old_or_new_instance\n\n!!! Internal use.\n\nGiven a recognized instance type, uses p_args keys round-{nearest,up,down} to either: (1) return them unmodified if all keys have value one; (2) return a copy of them that is multiplied by the ratio and rounded the specified way (no two keys may have a value different than one).\n\n\n\n\n\n","category":"method"},{"location":"CommandLine/#GuillotineModels.CommandLine.round_instance-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{GuillotineModels.Data.G2KP{D,S,P},Any,Any}} where P where S where D","page":"CommandLine","title":"GuillotineModels.CommandLine.round_instance","text":"round_instance(instance, factor, roundmode)\n\nReturn a new instance with all size-related fields multiplied by factor.\n\nThe roundmode (a Base.RoundingMode) specifies how the instances should be rounded back to their original types (as the factor is expected to be a Float64 and not an Integer).\n\nThis function should be extended for new instance types; if you want to use --round-{nearest,up,down} flags of GuillotineModels.CommandLine.run for new instance types just create a method that takes an instance of the new type, a Float64, and a Base.RoundingMode).\n\nThis function is called with this signature only if at least one option among round-{nearest,up,down} has a value different than one.\n\n!!! Unmodified arrays (like d) may be shared between old and new instances.\n\n\n\n\n\n","category":"method"},{"location":"CommandLine/#GuillotineModels.CommandLine.run","page":"CommandLine","title":"GuillotineModels.CommandLine.run","text":"run(args = ARGS; implemented_models = [...], supported_solvers = [...])\n\nParse the command-line arguments and take appropriate action: prints help or solve instance(s) in the specified file of the specified format for the specified problem using the specified solver, model, and their options.\n\nThe parameters available (listed in the help message and actually parsed) depend on the implemented_models and supported_solvers. The default values are the models and solvers made available by the GuillotineModels package. If you implement your own models or add support for more solvers you need to pass them there for them to be considered (and if you want the old ones to keep working you need to specify them also).\n\nThe best way to know everything this command is capable is to call:\n\nimport SUPPORTED_SOLVERS_YOU_HAVE_AVAILABLE\nimport GuillotineModels\nGuillotineModels.CommandLine.run(\n\t[\"--help\"];\n\tsupported_solvers = [SUPPORTED_SOLVERS_YOU_HAVE_AVAILABLE]\n)\n\nWhich will give you the help message. If you want to use it as an script you just need to remove the [\"--help\"] from the call.\n\n\n\n\n\n","category":"function"},{"location":"CommandLine/#GuillotineModels.CommandLine.throw_if_incompatible_options-Tuple{Any}","page":"CommandLine","title":"GuillotineModels.CommandLine.throw_if_incompatible_options","text":"throw_if_incompatible_options(p_args)\n\n!!! Internal use.\n\nCheck the already parsed arguments and test if options that are incompatible with each other were used.\n\n\n\n\n\n","category":"method"},{"location":"CommandLine/#GuillotineModels.CommandLine.toy_instance-Tuple{Any,Any}","page":"CommandLine","title":"GuillotineModels.CommandLine.toy_instance","text":"toy_instance(problem, format):: String\n\nReturn a String representing an instance of problem in format.\n\nThis is the function that should be extended in order to be able to call run with the --warm-jit with-toy.\n\n\n\n\n\n","category":"method"},{"location":"CommandLine/#GuillotineModels.CommandLine.warm_jit-Tuple{Any}","page":"CommandLine","title":"GuillotineModels.CommandLine.warm_jit","text":"warm_jit(p_args)\n\n!!! Internal use.\n\nLooks at p_args[\"warm-jit\"] and implements what is said in the flag description.\n\nSee also: toy_instance, read_build_solve_and_print\n\n\n\n\n\n","category":"method"},{"location":"CommandLine/#GuillotineModels.CommandLine.warn_if_changed_unused_values-Tuple{Any,Any,Any}","page":"CommandLine","title":"GuillotineModels.CommandLine.warn_if_changed_unused_values","text":"warn_if_changed_unused_values(p_args, models_list, solvers_list)\n\n!!! Internal use.\n\nGives warning messages if p_args has a value different from the default for an option of a model or solver that is not the one used. In other words, help a distracted user to not keep thinking it has passed an option to the used solver/model when they have not. Many solvers have the same option but with a different prefix, it is easy to change the solver used and forget to also change the prefix in the parameter options.\n\nIt is actually impossible to know if an argument was passed or not by the command-line after they are parsed by ArgParse because all of the arguments must have a default value and if the argument is not present in the command-line their default value is placed in the dict by ArgParse. This is the reason we just check if non-used options have values different from default, instead of just checking if they were provided.\n\nThis should work out-of-the-box for any third-party models or solvers given they implement their own version of accepted_arg_list and also have their identifying symbol passed in either models_list or solvers_list.\n\n\n\n\n\n","category":"method"},{"location":"SaveModel/#GuillotineModels.SaveModel","page":"GuillotineModels.SaveModel","title":"GuillotineModels.SaveModel","text":"","category":"section"},{"location":"SaveModel/","page":"GuillotineModels.SaveModel","title":"GuillotineModels.SaveModel","text":"CurrentModule = GuillotineModels","category":"page"},{"location":"SaveModel/","page":"GuillotineModels.SaveModel","title":"GuillotineModels.SaveModel","text":"Modules = [GuillotineModels.SaveModel]","category":"page"},{"location":"SaveModel/#GuillotineModels.SaveModel","page":"GuillotineModels.SaveModel","title":"GuillotineModels.SaveModel","text":"SaveModel module purpose is to provide a delegate-to-solver option to MathOptInterface.write_to_file. Instead of using the current MOI fallback (that only works for MPS and is kinda memory-hungry and slow), SaveModel.write_to_file checks if SaveModel.natively_supports returns true for its arguments, and in such case calls SaveModel.native_write_to_file over the object returned by the MOI.RawSolver() property; otherwise it calls the MOI fallback.\n\n\n\n\n\n","category":"module"},{"location":"SaveModel/#GuillotineModels.SaveModel.write_to_file-Tuple{JuMP.Model,String}","page":"GuillotineModels.SaveModel","title":"GuillotineModels.SaveModel.write_to_file","text":"write_to_file(model, filename; format = FORMAT_AUTOMATIC)\n\nSave the model to filename trying to use the solver mechanism instead of the generic JuMP/MathOptInterface one.\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GuillotineModels.Utilities","page":"Utilities","title":"GuillotineModels.Utilities","text":"","category":"section"},{"location":"Utilities/","page":"Utilities","title":"Utilities","text":"CurrentModule = GuillotineModels","category":"page"},{"location":"Utilities/","page":"Utilities","title":"Utilities","text":"Modules = [GuillotineModels.Utilities]","category":"page"},{"location":"Utilities/#GuillotineModels.Utilities.SavedVarConf","page":"Utilities","title":"GuillotineModels.Utilities.SavedVarConf","text":"Stores the type and bounds of a variable so they may be restored.\n\nwas_bin::Bool\nStores wether the variable was binary.\nwas_int::Bool\nStores wether the variable was integer (not binary, nor continuous).\nwas_fixed::Bool\nStores wether the variable was fixed.\nfix_value::Float64\nIf the variable was fixed, to which value they were fixed.\nhad_lb::Bool\nStores wether the variable had a lower bound.\nlb::Float64\nIf the variable had a lower bound, the value of their lower bound.\nhad_ub::Bool\nStores wether the variable had an upper bound.\nub::Float64\nIf the variable had an upper bound, the value of their upper bound.\n\n\n\n\n\n","category":"type"},{"location":"Utilities/#GuillotineModels.Utilities.SavedVarConf-Tuple{JuMP.VariableRef}","page":"Utilities","title":"GuillotineModels.Utilities.SavedVarConf","text":"SavedVarConf(var :: VariableRef) :: SavedVarConf\n\nCreates a SavedVarConf struct from the configuration of the given variable. Note that the VariableRef itself is not stored.\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GuillotineModels.Utilities.SortedLinkedLW","page":"Utilities","title":"GuillotineModels.Utilities.SortedLinkedLW","text":"Grouping of the length and width piece vectors (in original and sorted order), and their reverse indexes, allowing to, for example, iterate the pieces by length while having O(1) access to their width.\n\nl::Array{S,1} where S\nThe pieces length in the original order.\nw::Array{S,1} where S\nThe pieces width in the original order.\nsl::Array{S,1} where S\nThe pieces length sorted by increase-or-same order.\nsw::Array{S,1} where S\nThe pieces width sorted by increase-or-same order.\nsli2pii::Array{D,1} where D\nTranslator from indexes in sl to piece index (l and w).\nswi2pii::Array{D,1} where D\nTranslator from indexes in sw to piece index (l and w).\npii2sli::Array{D,1} where D\nTranslator from piece indexes (l and w) to index in sl.\npii2swi::Array{D,1} where D\nTranslator from piece indexes (l and w) to index in sw.\n\n\n\n\n\n","category":"type"},{"location":"Utilities/#GuillotineModels.Utilities.SortedLinkedLW-Union{Tuple{S}, Tuple{D}, Tuple{Type{D},Array{S,1},Array{S,1}}} where S where D","page":"Utilities","title":"GuillotineModels.Utilities.SortedLinkedLW","text":"SortedLinkedLW(::Type{D}, l :: [S], w :: [S])\n\nConstruts a SortedLinkedLW structure using type D as the type for indexes, and l and w as the pieces length and width in the 'original' ordering.\n\nNOTE: l and w are not copyed, so mutating them after  will silently and completely invalidate the entire structure. They are not copyed for performance reasons and because if the original vectors may be changed then the concept of 'original order' is not really relevant.\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GuillotineModels.Utilities.all_constraints-Tuple{JuMP.Model}","page":"Utilities","title":"GuillotineModels.Utilities.all_constraints","text":"all_constraints(m)\n\nJuMP only allow to query the number of constraints of some specific type; this method queries all constraint used in the model.\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GuillotineModels.Utilities.allsame-Tuple{Any}","page":"Utilities","title":"GuillotineModels.Utilities.allsame","text":"allsame(x) :: Bool\n\nReturns true if all elements inside x are the same (uses ==); false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GuillotineModels.Utilities.bits2idxs-Tuple{Any}","page":"Utilities","title":"GuillotineModels.Utilities.bits2idxs","text":"bits2idxs(bits, idx_type = Int) :: Vector{idx_type}\n\nGiven a BitArray or a Vector{Bool} return a vector of the indexes storing true values. The returned vector has its elements in increasing order.\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GuillotineModels.Utilities.expand-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{D,1},AbstractArray{T,1}}} where T where D","page":"Utilities","title":"GuillotineModels.Utilities.expand","text":"expand(d :: [D], a :: [T]) :: [T]\n\nGiven two vectors of the same size, create a copy of a that replaces each element a[i] by d[i] copies of it, and then flatten the copy.\n\nexpand([0, 1, 2, 3], [4, 5, 6, 7])\n[5, 6, 6, 7, 7, 7]\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GuillotineModels.Utilities.gather_nonzero-Union{Tuple{D}, Tuple{Any,Type{D}}, Tuple{Any,Type{D},Any}, Tuple{Any,Type{D},Any,Any}} where D","page":"Utilities","title":"GuillotineModels.Utilities.gather_nonzero","text":"gather_nonzero(vars, ::Type{D}, threshold = 1e-5, sol_idx = 1)\n\nGiven some valid JuMP.Model vars, return a list of all indexes in vars in which the variable value rounded to nearest integer is non-zero, and a list of the rounded values themselves.\n\nThe elements of the first list (variable indexes) are in increasing order.\n\nThe ::Type{D} is the integer type for the rounded values. The threshold parameter is used to give a warning if the difference between the extracted value (Float64) and the rounded value is larger than it. The sol_idx is passed to JuMP.value(...; result = sol_idx) to allow choosing which solution of the model is to be queried.\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GuillotineModels.Utilities.num_all_constraints-Tuple{Any}","page":"Utilities","title":"GuillotineModels.Utilities.num_all_constraints","text":"num_all_constraints(m) :: Int64\n\nJuMP only allow to query the number of constraints of some specific type; this method queries all constraint types used in the model and then sums the number of constraints of each type.\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GuillotineModels.Utilities.optimize_within_time_limit!","page":"Utilities","title":"GuillotineModels.Utilities.optimize_within_time_limit!","text":"optimize_within_time_limit!(model, start, limit[, now = time()])\noptimize_within_time_limit!(f, model, start, limit[, now = time()])\n\nThrows a TimeoutError if the time limit has been violated before calling the JuMP.optimize!, change the solver to respect a time limit of the remaining time, throws a TimeoutError if the solver termination status is MOI.TIME_LIMIT OR calling time() shows a time limit violation.\n\nIf the method with the f parameter is called, and a timeout happens, then f is called with four parameters: model, start, limit, and the value returned by a call to time() just after the model stopping. If f returns true then the exception is not thrown, any other return value is ignored and the exception is thrown.\n\n\n\n\n\n","category":"function"},{"location":"Utilities/#GuillotineModels.Utilities.optimize_within_time_limit!-Tuple{Any,Float64}","page":"Utilities","title":"GuillotineModels.Utilities.optimize_within_time_limit!","text":"optimize_within_time_limit!(model, secs)\n\nSet the solver time limit to secs seconds and call optimize!. Change the solver time limit to the old value before returning.\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GuillotineModels.Utilities.relax!-Tuple{JuMP.VariableRef}","page":"Utilities","title":"GuillotineModels.Utilities.relax!","text":"relax!(var) :: SavedVarConf\nrelax!(vars) :: Vector{SavedVarConf}\n\nThe var is made continuous. If the variable was binary, and had a lower (upper) bound below zero (above one) it is replaced by zero (one).\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GuillotineModels.Utilities.restore!-Tuple{JuMP.VariableRef,GuillotineModels.Utilities.SavedVarConf}","page":"Utilities","title":"GuillotineModels.Utilities.restore!","text":"restore!(var :: VariableRef, c :: SavedVarConf) :: Nothing\nrestore!(vars :: Vector{...}, cs :: Vector{...}) :: Nothing\n\nIf var type and/or bounds are different than the ones specified in c, then change var type and/or bounds to adhere to c.\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GuillotineModels.Utilities.shift_idxs!-Tuple{Any,Any}","page":"Utilities","title":"GuillotineModels.Utilities.shift_idxs!","text":"shift_idxs!(old_idxs, kept_bits)\n\nGiven a sorted list of indexes (old_idxs) from a vector A and a bitarray-like (kept_bits) marking (with true) which positions of A were not deleted since last shift_idxs!, it changes the old_idxs to point to the correct positions and return it.\n\nThe code throws if the old_idxs are not positions marked as kept by kept_bits.\n\nThis code is efficient if old_idxs is a \"small\" subset of A indexes.\n\nThe code assumes A had the usual 1:length(A) indexes.\n\nThe code does not allocate from the heap.\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GuillotineModels.Utilities.switched_dims-Union{Tuple{GuillotineModels.Utilities.SortedLinkedLW{D,S}}, Tuple{S}, Tuple{D}} where S where D","page":"Utilities","title":"GuillotineModels.Utilities.switched_dims","text":"switched_dims(sllw :: SortedLinkedLW{D, S}) where {D, S}\n\nReturns a copy of sllw as it was created switching L/W and l/w.\n\nDANGER: Both the original and the copy share the same arrays, so any modification in one will change the other.\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GuillotineModels.Utilities.throw_if_unrecognized-Tuple{Any,Any,Any}","page":"Utilities","title":"GuillotineModels.Utilities.throw_if_unrecognized","text":"throw_if_unrecognized(name, value, list)\n\nIf value is NOT in list, then throw an argument error explaining that because value is not in list so it is a valid value for parameter name.\n\n\n\n\n\n","category":"method"},{"location":"Utilities/#GuillotineModels.Utilities.unify!-Union{Tuple{QT_TYPE}, Tuple{Type{QT_TYPE},Any}} where QT_TYPE","page":"Utilities","title":"GuillotineModels.Utilities.unify!","text":"unify!(::Type{QT_TYPE}, a)\n\nApply sort! and unique! to array a and then returns a Vector{QT_TYPE} with the corresponding quantity of value in a before compacting it.\n\n> a = [40, 10, 20, 10, 20, 30, 20];\n\n> unify!(Int16, a)\n4-element Array{Int16,1}:\n 2\n 3\n 1\n 1\n\n> a\n4-element Array{Int64,1}:\n 10\n 20\n 30\n 40\n\n\n\n\n\n\n","category":"method"},{"location":"Flow-Enumeration/#GuillotineModels.Flow.Enumeration","page":"Flow.Enumeration","title":"GuillotineModels.Flow.Enumeration","text":"","category":"section"},{"location":"Flow-Enumeration/","page":"Flow.Enumeration","title":"Flow.Enumeration","text":"CurrentModule = GuillotineModels","category":"page"},{"location":"Flow-Enumeration/","page":"Flow.Enumeration","title":"Flow.Enumeration","text":"Modules = [GuillotineModels.Flow.Enumeration]","category":"page"},{"location":"Flow-Enumeration/#GuillotineModels.Flow.Enumeration","page":"Flow.Enumeration","title":"GuillotineModels.Flow.Enumeration","text":"Collection of the methods used for generating the graph representing the flow model.\n\n\n\n\n\n","category":"module"},{"location":"Flow-Enumeration/#GuillotineModels.Flow.Enumeration.Edge","page":"Flow.Enumeration","title":"GuillotineModels.Flow.Enumeration.Edge","text":"An edge of the GuillotineModels.Flow Model.\n\nindx::Any\nUnique identifier of the edge in the model.\nhead::Any\nThe node from where the flow comes. Source.\ntail::Any\nThe node from where the flow ends. Sink.\nback::Any\nThe backward edge global index, if it exists, otherwise zero.\n\n\n\n\n\n","category":"type"},{"location":"Flow-Enumeration/#GuillotineModels.Flow.Enumeration.Node","page":"Flow.Enumeration","title":"GuillotineModels.Flow.Enumeration.Node","text":"A node of the GuillotineModels.Flow model.\n\nidx::Any\nUnique identifier of the node in the model.\npar::Any\nThe size of the plate dimension parallel to the cuts.\nper::Any\nThe size of the plate dimension perpendicular to the cuts.\nori::UInt8\nThe cut orientation: one means vertical cuts; two means horizontal cuts.\n\n\n\n\n\n","category":"type"},{"location":"Flow-Enumeration/#GuillotineModels.Flow.Enumeration.gen_all_edges-Union{Tuple{E}, Tuple{N}, Tuple{S}, Tuple{D}, Tuple{Type{N},Type{E},Array{D,1},Array{S,1},Array{S,1},S,S}} where E where N where S where D","page":"Flow.Enumeration","title":"GuillotineModels.Flow.Enumeration.gen_all_edges","text":"gen_nodes_and_edges(N, E, d, l, w, L, W) :: ([Node], [Edge], N, E)\n\n!!! Internal use.\n\nGiven the integer types used to number nodes and edges, the piece set, and the original plate length, create all nodes and edges except by some dummy ones (that are handled specially and, so, should not even be mixed here).\n\nNotes\n\nThis method is aware the edge identifiers 1 to n+4 are special.\nThis method creates the special edges n+2 and n+4, but not any other in the 1:n+4 special identifier interval.\n\nHigh-level procedure description\n\nCompute the discretized lengths (widths).\nFor each discretized length (width), create a flow with max width (length).\nThe backward edges in not-yet-reached flow B may be referred in currently-being-built flow A (a subplate edge from A may enable more flow to a backward edge in B). To solve this problem, a structure is passed around, it is a matrix of three dimensions, which may indexed by the values that are unique for a backward edge (pardim, cutori, per_dim), and stores the identifier for the unique backward edge with such attributes. If some forward edge created need to refer to a backward edge it is receives its identifier at that moment and is always referred by it, the corresponging Edge struct however, is only created at the final of the procedure, when all backward edges are known.\nBackward Edges are similar to waste edges in the fact both of they have the back field as zero (they never enable another backward edge), however only backward edges have tails pointing to the source nodes of flows (and, consequently, the only ones with tails before heads).\n\n\n\n\n\n","category":"method"},{"location":"Flow-Enumeration/#GuillotineModels.Flow.Enumeration.gen_closed_flow-Union{Tuple{E}, Tuple{N}, Tuple{S}, Tuple{D}, Tuple{N,E,AbstractArray{D,2},Array{E,3},Array{D,1},Array{S,1},Array{S,1},UInt8,S,S}} where E where N where S where D","page":"Flow.Enumeration","title":"GuillotineModels.Flow.Enumeration.gen_closed_flow","text":"gen_closed_flow(...)\n\n!!! Internal use.\n\nGiven some \"global\" structures/counters (last_gnode_idx, last_gedge_idx, lw2pii, ppo2gbedge_idx), the piece set (d, par, per) and the plate dimensions and its allowed cut orientation (ori, PAR, PER), this method builds the graph that represents all allowed cuts over such plate. The only changed parameter is ppo2gbedge_idx.\n\nArguments\n\nlast_gnode_idx::N: The highest global node identifier already in use.\nlast_gedge_idx::E: The highest global edge identifier already in use.\nlw2pii::AbstractArray{D, 2}: A convenient table that translates the dimensions of a piece to the global piece code if there exists a piece that fits the description. It is not changed but a transposition of it is made frequently.\nppo2gbedge_idx::Array{E, 3}: A table that translates the parallel-perpendicular-orientation triple to the global backward edge index, if it exists. If there is the need to refer to a circulation edge but its global identifier does not yet exists, it is created and saved to the table.\nd::Vector{D}: The demand of the pieces.\npar::Vector{S}: The size of the pieces in the dimension that is parallel to the cuts made in this flow.\nper::Vector{S}: The size of the pieces in the dimension that is perpendicular to the cuts made in this flow.\nori::UInt8: If it is one, the flow is making vertical cuts, and therefore par is l and per is w. If it is two, the flow is making horizontal cuts and therefore par is w and per is l.\nPAR::S: The size of the flow/plate in the dimension that is parallel to the cuts made.\nPER::S: The size of the flow/plate in the dimension that is perpendicular to the cuts made.\n\nReturns\n\nA dense list of globalized nodes (all nodes in sequence).\nA sparse list of globalized nodes (if position y has a corresponding node, then v[y] == globalized_node_id, otherwise v[y] == 0).\nA dense list of the globalized edges.\nThe index of the last globalized node (after the procedure).\nThe index of the last globalized edge (after the procedure).\n\n\n\n\n\n","category":"method"},{"location":"Flow-Enumeration/#GuillotineModels.Flow.Enumeration.gen_rr_fow_edges!-Union{Tuple{N}, Tuple{S}, Tuple{D}, Tuple{Type{N},Array{D,1},Array{S,1},S}} where N where S where D","page":"Flow.Enumeration","title":"GuillotineModels.Flow.Enumeration.gen_rr_fow_edges!","text":"gen_rr_fow_edges!(::Type{N}, d :: [D], l :: [S], L :: S) :: ([N], [(S, S)])\n\n!!! Internal use.\n\nArguments\n\nAn integer type capable of representing the nodes N. The pieces demand d, their length (or width) l, and a plate length (or width) L. This method assumes the selected pieces fit the selected plate (on both dimensions, this is, in the one that was given and the one that wasn't).\n\nReturn\n\nA tuple of two vectors:\n\na vector v of length L; v[y] == 1 iff there is a linear combination of the pieces (respecting demand) that gives y; otherwise v[y] == 0.\na vector containing all ordered pairs of linear combinations in which the difference between the two is exactly the size of a piece.\n\n\n\n\n\n","category":"method"},{"location":"Flow-Enumeration/#GuillotineModels.Flow.Enumeration.gen_u_fow_edges-Union{Tuple{E}, Tuple{N}, Tuple{S}, Tuple{Array{GuillotineModels.Flow.Enumeration.Node{S,N},1},Array{N,1},E,Array{E,3}}} where E where N where S","page":"Flow.Enumeration","title":"GuillotineModels.Flow.Enumeration.gen_u_fow_edges","text":"gen_u_fow_edges(glo_nodes, y2node_idx, last_gedge_idx, ppo2gbedge_idx)\n\n!!! Internal use.\n\nThis method generate the unrestricted subplate edges, i.e., the subplate edges representing a cut that creates a subplate in which the size of the dimension that is perpendicular to the cut is not the size of a single piece, but of a linear combination of them. Such edges are necessary to solve the unrestricted case but not to solve restricted case.\n\nArguments\n\nglo_nodes::Vector{Node{S, N}}: A list of globalized nodes from a single graph (asserts will fail if nodes are from different graphs).\ny2node_idx::Vector{N}: A vector in which !iszero(y2node_idx[y]) only if y is the per value of some node in glo_nodes and zero otherwise.\nlast_gedge_idx::E: The highest global edge identifier already in use.\nppo2gbedge_idx::Array{E, 3}: A table that translates the parallel-perpendicular-orientation triple to the global backward edge index, if it exists. If there is the need to refer to a circulation edge but its global identifier does not yet exists, it is created and saved to the table.\n\nProcedure\n\nLoop through all pairs i and j (i < j) of node indexes (not counting a possibly dummy sink node, but counting the source node), create a edge between the two nodes if glo_nodes[j].per - glo_nodes[i].per <= glo_nodes[i].per.\n\nReturns\n\nThe list of new edges, already globalized.\nThe last edge index attributed.\n\n\n\n\n\n","category":"method"},{"location":"Flow-Enumeration/#GuillotineModels.Flow.Enumeration.gen_w_fow_edges-Union{Tuple{E}, Tuple{N}, Tuple{S}, Tuple{Array{GuillotineModels.Flow.Enumeration.Node{S,N},1},E}} where E where N where S","page":"Flow.Enumeration","title":"GuillotineModels.Flow.Enumeration.gen_w_fow_edges","text":"gen_w_fow_edges(glo_nodes, last_gedge_idx) :: ([Edge], E)\n\n!!! Internal use.\n\nGiven a set of \"globalized\" nodes, and the index of the last \"globalized\" edge, create the set of corresponding waste edges (already \"globalized\").\n\nFor now, it is not very smart and just connect the second node to the third, third to the fourth, and so on. Ideally, it should connect every node (except the first) to the next node that has a backward edge associated (not counting the node in question, clearly, no self-loops allowed).\n\n\n\n\n\n","category":"method"},{"location":"Flow-Enumeration/#GuillotineModels.Flow.Enumeration.globalize!-Union{Tuple{E}, Tuple{N}, Tuple{S}, Tuple{D}, Tuple{Array{N,1},Array{Tuple{S,S},1},N,E,AbstractArray{D,2},Array{E,3},UInt8,S}} where E where N where S where D","page":"Flow.Enumeration","title":"GuillotineModels.Flow.Enumeration.globalize!","text":"globalize!(see description and source for parameters and return)\n\n!!! Internal use.\n\nThe model may be seen as constituted of many independent graphs, but as there is interaction between them (i.e., subplate edges increase the flow of a backward edge in other graph) their nodes and edges must follow a global numbering and the backward edges must be known by all of graphs (as subplate edges need to refer to them as child plates).\n\nThis method takes the \"local/raw\" lists of node (y2node_idx) and edge (raw_fow_edges) numbering (that is just the normal cut positions); the index of the last globalized node (last_gnode_idx) and edge (last_gedge_idx); a matrix that gives the piece index given the piece dimensions (lw2pii); a tridimensional array that gives the backward edge index given its plate dimensions and allowed cut orientation (ppo2gbedge_idx); the allowed cut orientation of the given graph; and the size of the plate dimension parallel to the allowed cuts (PAR).\n\nThe method return the \"globalized\" list of nodes and edges, as the index of the last globalized node and edge.\n\nThe method changes ppo2gbedge_idx: if a subplate (forward) edge is created and the corresponding backward edge was not yet numbered, it is given a \"globalized\" index (all backward edges are created at another step at the end).\n\n\n\n\n\n","category":"method"},{"location":"Flow-Enumeration/#GuillotineModels.Flow.Enumeration.merge_duplicates-Union{Tuple{S}, Tuple{D}, Tuple{Array{D,1},Array{S,1}}} where S where D","page":"Flow.Enumeration","title":"GuillotineModels.Flow.Enumeration.merge_duplicates","text":"merge_duplicates(d :: [D], per :: [S]) :: ([D], [S])\n\n!!! Internal use.\n\nIf per has no repeated values just return the parameters. Otherwise, for each value in per with duplicates, keep just one copy of such value inside per and delete the other copies, and the same positions in d; the position in d corresponding to the kept copy will have the sum of the d values for all copies deleted and the copy kept. Sort per by increasing value and swap positions in d to keep the correspondence.\n\n\n\n\n\n","category":"method"},{"location":"Flow-Enumeration/#GuillotineModels.Flow.Enumeration.reduce_dlw-Union{Tuple{S}, Tuple{D}, Tuple{Array{D,1},Array{S,1},Array{S,1},S,S}} where S where D","page":"Flow.Enumeration","title":"GuillotineModels.Flow.Enumeration.reduce_dlw","text":"reduce_dlw(d::[D], l::[S], w::[S], L::S, W::S) :: ([D], [S], [S], D)\n\n!!! Internal use.\n\nCreate a copy of d, l, and w with only the pieces that fit the plate L x W (i.e., pieces with both dimensions smaller than the corresponding plate dimension). The last value returned is the number of pieces that pass this criteria (and, consequently, the common size of the returned vectors).\n\n\n\n\n\n","category":"method"},{"location":"Data/#GuillotineModels.Data","page":"GuillotineModels.Data","title":"GuillotineModels.Data","text":"","category":"section"},{"location":"Data/","page":"GuillotineModels.Data","title":"GuillotineModels.Data","text":"CurrentModule = GuillotineModels","category":"page"},{"location":"Data/","page":"GuillotineModels.Data","title":"GuillotineModels.Data","text":"Modules = [GuillotineModels.Data]","category":"page"},{"location":"Data/#GuillotineModels.Data","page":"GuillotineModels.Data","title":"GuillotineModels.Data","text":"Data groups the instance-parsing functions and the types involved.\n\nThe parsing is extensible, as users can define any new types and extend the parsing functions to the types. It is advised to always return the same type for the same format type given as input, to avoid type-unstability and have a clear mapping. However, \"auto\" formats can also be created, to simplify the user's life (in special during testing) paying for a little overhead (and risk of misdetection).\n\nThe parsing function is extended for parametric types (e.g., Classic_G2KP{D, S, P}) so the data type returned (e.g., G2KP{D, S, P}) has the demand/N/M (D), length/width (S), and profit/area (P) fields with the right types. The function is also extend to Val types for convenience.  They often map to a parametric type with sensible safe defaults (e.g.  Val{:Classic_G2KP} -> Classic_G2KP{Int, Int, Int}). But a finer-grained control is also possible, as you can define something like (Val{:Classic_G2KP_16} -> Classic_G2KP_16{Int16, Int16, Int16}). Val parameters are also important because module CommandLine currently takes Strings that are passed to (Val ∘ Symbol) in order to define the instance format to be used.\n\nThis module already extends the instance reading for many instance formats. From the 2DCPackGen (further abbreviated here as CPG, Cutting and Packing Generator, because structs cannot start with a digit), the module supports: SLOPP, MHLOPPW, ODPW, and SSSCSP. They all follow the same pattern: SLOPP (the struct type with the data), CPG_SLOPP{D, S, P} (for the clearly typed format type), and Val{:CPG_SLOPP} for the safe defaults (i.e., the same as CPG{Int, Int, Int}, note this will be 32 in some machined and 64 in others). For details on these formats look at the 2DCPackGen tool.\n\nSome file formats aggregate multiple instances in a single file. To allow generic functions to deal with this possibility, it is recommended to specialize GuillotineModels.Data.is_collection. This function should be specialized for the format type (not the return of the parsing). A format that does not specialize it is assumed to return a single instance upon parsing (i.e., GuillotineModels.Data.read_from_string).\n\nThe Classic_G2KP/G2KP format/data is also provided in the same fashion. The format is described in the method documentation.\n\nThe function may @warn the users of \"strange\" (but not incorrect) structure of the given instance, and error if the format is incorrect.\n\nThe current methods dispatch on the type of the first object, even if all current format types have empty objects. Consequently, instantiations like CPG_SLOPP{Int8, Int16, Int32}() and Val(:CPG_SLOPP) are expected, instead of just the type itself. In the future may be possible to add parsing options/configuration inside the format objects.\n\n\n\n\n\n","category":"module"},{"location":"Data/#GuillotineModels.Data.GenericParseError","page":"GuillotineModels.Data","title":"GuillotineModels.Data.GenericParseError","text":"GenericParseError(format, error_message)\n\nMost general error thrown by parse_from_string when it fails.\n\nIdeally, methods extending parse_from_string should use a subtype of ParseError, either custom or this one.\n\n\n\n\n\n","category":"type"},{"location":"Data/#GuillotineModels.Data.ParseError","page":"GuillotineModels.Data","title":"GuillotineModels.Data.ParseError","text":"abstract type ParseError <: Exception end\n\nSupertype for parse errors.\n\n\n\n\n\n","category":"type"},{"location":"Data/#GuillotineModels.Data.is_collection-Tuple{Any}","page":"GuillotineModels.Data","title":"GuillotineModels.Data.is_collection","text":"is_collection(format) :: Bool\n\nIndicate if a format is parsed to a single instance or to a collection.\n\nIf the format may store a variable number of instances, then passing the format object to this function should return true; if the format always store a single instance, then it should return false.\n\nIf this function is not specialized it assumes the format parses to a single instance.\n\nIf the function returns true for some format, it is assumed that the value returned by read_from_string (and its file counterpart) respect the Base.iterate interface; if a file in this format has just a single instance, this single instance should be wrapped in the same container used when there are multiple instances (any overhead caused by wrapping will probably not be larger than the overhead caused by type unstability).\n\nIdeally, the value returned should not depend on the value of the argument, but only the type of the argument.\n\n\n\n\n\n","category":"method"},{"location":"Data/#GuillotineModels.Data.read_from_file-Tuple{Any,AbstractString}","page":"GuillotineModels.Data","title":"GuillotineModels.Data.read_from_file","text":"read_from_file(format, filepath :: AbstractString)\n\nReads the given file and apply read_from_string to its contents.\n\nThe (already provided) generic body of this function should be enough for most formats without the need of explicit specialization.\n\nNote: this function remove all '\\r' characters from the obtained String to avoid 'dos' vs 'unix' format inconsistencies.\n\nSee also: read_from_string\n\n\n\n\n\n","category":"method"},{"location":"Data/#GuillotineModels.Data.read_from_string-Tuple{Val{:CPG_MHLOPPW},AbstractString}","page":"GuillotineModels.Data","title":"GuillotineModels.Data.read_from_string","text":"read_from_string(::Val{:CPG_MHLOPPW}, s :: AbstractString)\n\nConvenience method. To be called as read_from_string(Val(:CPG_MHLOPPW), s). Equivalent to the call read_from_string(CPG_MHLOPPW{Int, Int, Int}(), s).\n\n\n\n\n\n","category":"method"},{"location":"Data/#GuillotineModels.Data.read_from_string-Tuple{Val{:CPG_ODPW},AbstractString}","page":"GuillotineModels.Data","title":"GuillotineModels.Data.read_from_string","text":"read_from_string(::Val{:CPG_ODPW}, s :: AbstractString)\n\nConvenience method. To be called as read_from_string(Val(:CPG_ODPW), s). Equivalent to the call read_from_string(CPG_ODPW{Int, Int, Int}(), s).\n\n\n\n\n\n","category":"method"},{"location":"Data/#GuillotineModels.Data.read_from_string-Tuple{Val{:CPG_SLOPP},AbstractString}","page":"GuillotineModels.Data","title":"GuillotineModels.Data.read_from_string","text":"read_from_string(::Val{:CPG_SLOPP}, s :: AbstractString)\n\nConvenience method. To be called as read_from_string(Val(:CPG_SLOPP), s). Equivalent to the call read_from_string(CPG_SLOPP{Int, Int, Int}(), s).\n\n\n\n\n\n","category":"method"},{"location":"Data/#GuillotineModels.Data.read_from_string-Tuple{Val{:CPG_SSSCSP},AbstractString}","page":"GuillotineModels.Data","title":"GuillotineModels.Data.read_from_string","text":"read_from_string(::Val{:CPG_SSSCSP}, s :: AbstractString)\n\nConvenience method. To be called as read_from_string(Val(:CPG_SSSCSP), s). Equivalent to the call read_from_string(CPG_SSSCSP{Int, Int, Int}(), s).\n\n\n\n\n\n","category":"method"},{"location":"Data/#GuillotineModels.Data.read_from_string-Tuple{Val{:Classic_G2KP},AbstractString}","page":"GuillotineModels.Data","title":"GuillotineModels.Data.read_from_string","text":"read_from_string(::Val{:Classic_G2KP}, s :: AbstractString)\n\nConvenience method. To be called as read_from_string(Val(:Classic_G2KP), s). Equivalent to the call read_from_string(Classic_G2KP{Int, Int, Int}(), s).\n\n\n\n\n\n","category":"method"},{"location":"Data/#GuillotineModels.Data.read_from_string-Tuple{Val{:Simple_CPG_SLOPP},AbstractString}","page":"GuillotineModels.Data","title":"GuillotineModels.Data.read_from_string","text":"read_from_string(::Val{:Simple_CPG_SLOPP}, s :: AbstractString)\n\nConvenience method. To be called as read_from_string(Val(:Simple_CPG_SLOPP), s). Equivalent to the call read_from_string(Simple_CPG_SLOPP{Int, Int, Int}(), s).\n\n\n\n\n\n","category":"method"},{"location":"Data/#GuillotineModels.Data.read_from_string-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{GuillotineModels.Data.CPG_Format{D,S,P},AbstractString}} where P where S where D","page":"GuillotineModels.Data","title":"GuillotineModels.Data.read_from_string","text":"read_from_string(format :: CPG_Format{D, S, P}, s :: AbstractString)\n\nExpect a string in the format given and parse it to the adequate instance object. The format may be CPG_SLOPP{D, S, P}(), CPG_MHLOPPW{D, S, P}(), CPG_ODPW{D, S, P}(), CPG_SSSCSP{D, S, P}(). All these formats come from 2DCPackGen (10.1016/j.ejor.2014.02.059, see https://sites.google.com/gcloud.fe.up.pt/cutting-and-packing-tools/2dcpackgen for the code). Each of these formats starts with a self-explanatory header. These headers are copyied below.\n\n***2D Rectangular Problem***\n***Instances for the Single Large Object Placement Problem (SLOPP)***\nInput parameter file: SLOPP_parameters.txt\n***************************************************************************************************************\nTotal number of instances\nLargeObject.Length      LargeObject.Width\nNumber of different item types (i)\nItem[i].Length  Item[i].Width   Item[i].LowerBoundDemand        Item[i].UpperBoundDemand        Item[i].Value\n***************************************************************************************************************\n\n***2D Rectangular Problem***\n***Instances for the Multiple Heterogeneous Large Object Placement Problem (MHLOPP/W)***\nInput parameter file: MHLOPPW_parameters.txt\n***************************************************************************************************************\nTotal number of instances \nNumber of different large objects (j) \nLargeObject[j].Length   LargeObject[j].Width    LargeObject[j].Available\nNumber of different item types (i) \nItem[i].Length  Item[i].Width   Item[i].LowerBoundDemand        Item[i].UpperBoundDemand        Item[i].Value\n***************************************************************************************************************\n\n***2D Rectangular Problem***\n***Problem tests for the Open Dimension Problem (ODP/W)***\nInput parameter file: ODPW_parameters.txt\n***********************************************************************\nTotal number of instances \nNumber of different large objects (j)\nLargeObject[j].Width    LargeObject[j].Available        LargeObject[j].Value\nNumber of different item types (i)\nItem[i].Length  Item[i].Width   Item[i].Demand\n***********************************************************************\n\n***2D Rectangular Problem***\n***Instances for the Single Stock Size Cutting Stock Problem (SSSCSP)***\nInput parameter file: SSSCSP_parameters.txt\n****************************************************************************************************\nTotal number of instances\nLargeObject.Length      LargeObject.Width\nNumber of different item types (i)\nItem[i].Length  Item[i].Width   Item[i].Demand\n*****************************************************************************************************\n\nThe D, S, and P type parameters indicate the integer type which should be used to store Demand, Size, and Profit (or piece/plate area).\n\nReturns an object of type YYY{D, S, P} in which YYY is what comes after CPG_ in the given format type.\n\n\n\n\n\n","category":"method"},{"location":"Data/#GuillotineModels.Data.read_from_string-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{GuillotineModels.Data.Classic_G2KP{D,S,P},AbstractString}} where P where S where D","page":"GuillotineModels.Data","title":"GuillotineModels.Data.read_from_string","text":"read_from_string(_ :: Classic_G2KP{D, S, P}, s :: AbstractString)\n\nExpect a string in the following format:\n\n<L> <W>\n<N>\n<l_1> <w_1> <p_1> <d_1>\n<l_2> <w_2> <p_2> <d_2>\n...\n\nL and W are the original plate length and width. N is the number of pieces in the instance. The l, w, p, and d, are the length, width, profit, and demand, of a piece.\n\nThe D, S, and P type parameters indicate the integer type which should be used to store Demand, Size, and Profit (or piece/plate area).\n\nReturns a G2KP{D, S, P} object.\n\nNotes\n\nIf N is smaller than the number of lines after it, just the first N lines will be parsed and passed to the returned object.\nEmpty lines and multiples spaces/tabs between columns may happen, but each non-empty line should contain the expected number of columns (i.e., the first non-empty line should have one number, the second non-empty line two numbers, all remaining non-empty lines four numbers).\n\nSee also: read_from_file\n\n\n\n\n\n","category":"method"},{"location":"Data/#GuillotineModels.Data.read_from_string-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{GuillotineModels.Data.Simple_CPG_SLOPP{D,S,P},AbstractString}} where P where S where D","page":"GuillotineModels.Data","title":"GuillotineModels.Data.read_from_string","text":"read_from_string(_ :: Simple_CPG_SLOPP{D, S, P}, s :: AbstractString)\n\nSimilar to read_from_string(CPG_SLOPP{D, S, P}(), s) which is described in read_from_string(format :: CPG_Format{D, S, P}, s :: AbstractString), the only difference in format compared to CPG_SLOPP is that Simple_CPG_SLOPP format expects just a single instance and no header.\n\n\n\n\n\n","category":"method"},{"location":"Data/#GuillotineModels.Data.write_to_file","page":"GuillotineModels.Data","title":"GuillotineModels.Data.write_to_file","text":"write_to_file(format, instance, filepath :: AbstractString[, mode])\nwrite_to_file(format, instance, io)\n\nWite the instance in filepath/io using format.\n\nNOTE: this function is not yet implemented for most format and instance types.\n\nmode is passed to open, by default it is: \"w+\".\n\nNew format/instance combinations should implement a method taking an io::IO third parameter (otherwise ambiguity problems may arise).  The generic method taking a filename just open the file and call the io-like version over it.\n\nNote: the write_to_string methods implemented by this package does not use '\\r\\n' (carriage return line endings) just '\\n'.\n\nTo write to a String, pass an empty IOBuffer object and after the call execute read(seekstart(iob), String) to extract the String (this is the most efficient way).\n\nSee also: read_from_file, read_from_string\n\n\n\n\n\n","category":"function"},{"location":"PPG2KP/#GuillotineModels.PPG2KP","page":"PPG2KP","title":"GuillotineModels.PPG2KP","text":"","category":"section"},{"location":"PPG2KP/","page":"PPG2KP","title":"PPG2KP","text":"CurrentModule = GuillotineModels","category":"page"},{"location":"PPG2KP/","page":"PPG2KP","title":"PPG2KP","text":"Modules = [GuillotineModels.PPG2KP]","category":"page"},{"location":"PPG2KP/#GuillotineModels.PPG2KP.VarInvIndexes","page":"PPG2KP","title":"GuillotineModels.PPG2KP.VarInvIndexes","text":"Auxiliar struct used to build the PPG2KP model.\n\nAggregates the inverted indexes that indicate the variables with non-zero coefficients in model constraints.\n\npii2pair::Array{Array{P,1},1} where P\nIf indexed by a piece index, returns the indexes of all extraction variables (picuts/np) that extract that piece from some plate.\n\npli2pair::Array{Array{P,1},1} where P\nIf indexed by a plate index, returns the indexes of all extraction variables (picuts/np) that extract some piece from that plate.\n\nchild2cut::Array{Array{P,1},1} where P\nIf indexed by a plate index, returns the indexes of all cut variables (cuts_made/cuts) that have that plate as either first or second child (i.e., one of the plates generated by the cut).\n\nparent2cut::Array{Array{P,1},1} where P\nIf indexed by a plate index, returns the indexes of all cut variables (cuts_made/cuts) that have that plate as the parent of the cut (i.e., the plate that is being cut).\n\n\n\n\n\n","category":"type"},{"location":"PPG2KP/#GuillotineModels.PPG2KP.VarInvIndexes-Union{Tuple{GuillotineModels.PPG2KP.Enumeration.ByproductPPG2KP{D,S,P}}, Tuple{P}, Tuple{S}, Tuple{D}} where P where S where D","page":"PPG2KP","title":"GuillotineModels.PPG2KP.VarInvIndexes","text":"VarInvIndexes(bp :: ByproductPPG2KP{D, S, P}) :: VarInvIndexes{P}\n\nUtility constructor that creates the struct from a ByproductPPG2KP.\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP/#GuillotineModels.PPG2KP.VarInvIndexes-Union{Tuple{P}, Tuple{P,P,Any,Any}} where P<:Integer","page":"PPG2KP","title":"GuillotineModels.PPG2KP.VarInvIndexes","text":"VarInvIndexes(num_piece_types, num_plate_types, np, cuts)\n\nUtility constructor that creates the struct from a ByproductPPG2KP.\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP/#GuillotineModels.PPG2KP.cuts_and_extractions_from_2_staged_solution-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{Array{Array{D,1},1},GuillotineModels.PPG2KP.Enumeration.ByproductPPG2KP{D,S,P},GuillotineModels.PPG2KP.BaseModel}} where P where S where D","page":"PPG2KP","title":"GuillotineModels.PPG2KP.cuts_and_extractions_from_2_staged_solution","text":"cuts_and_extractions_from_2_staged_solution(pattern, bp, bm)\n\nGiven a 2-staged pattern and a PPG2KP model bp (byproduct), returns the cuts (bp.cuts indexes) and extractions (bp.np indexes) that make up a valid solution representing such pattern. Note: this is intended to be called over non-priced PPG2KP models; if the model is priced the variables assumed to exist in this code may not exit anymore (especially if Furini's multistep pricing is used).\n\nThe pattern parameter has many restrictions:\n\nIt is 2-staged, what is enforced by being a vector of vectors.\nEach inner vector is a vertical stripe with the width of the first piece inside such inner vector. No horizontal stripes allowed. No piece inside an inner vector has width larger than the first piece of the inner vector.\nThe first inner vector has the largest stripe width.\nNo inner vectors should be empty. Every number is a valid piece type index.\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP/#GuillotineModels.PPG2KP.mip_start_by_heuristic!-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{Any,GuillotineModels.PPG2KP.Enumeration.ByproductPPG2KP{D,S,P},Any,Any,GuillotineModels.PPG2KP.BaseModel}} where P where S where D","page":"PPG2KP","title":"GuillotineModels.PPG2KP.mip_start_by_heuristic!","text":"mip_start_by_heuristic!(model, seed, p, bp, bm)\n\nTODO: document. Returns two tuples, the first is the result of internal fast_iterated_greedy the second tuple contain the last four arguments of the rawmipstart! used to MIP-start the model (this way unsetmipstart! can be easily called over the model).\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP/#GuillotineModels.PPG2KP.raw_mip_start!-NTuple{5,Any}","page":"PPG2KP","title":"GuillotineModels.PPG2KP.raw_mip_start!","text":"raw_mip_start!(model, nz_pe_idxs, nz_pe_vals, nz_cm_idxs, nz_cm_vals)\n\nTODO: document.\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP/#GuillotineModels.PPG2KP.save_mip_start-Tuple{Any}","page":"PPG2KP","title":"GuillotineModels.PPG2KP.save_mip_start","text":"save_mip_start(model)\n\nTODO: document. Returns the four last arguments of rawmipstart!\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP/#GuillotineModels.PPG2KP.unset_mip_start!-Tuple{Any,Any,Any}","page":"PPG2KP","title":"GuillotineModels.PPG2KP.unset_mip_start!","text":"unset_mip_start!(model, nz_pe_idxs, nz_cm_idxs)\n\nTODO: document. Just take the first and third returned values from save_mip_start! (or the first and third parameters of raw_mip_start! because the specific values of the old start are irrelevant).\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP/#GuillotineModels.build_model-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{Val{:G2CSP},Val{:PPG2KP},GuillotineModels.Data.G2KP{D,S,P},Any}, Tuple{Val{:G2CSP},Val{:PPG2KP},GuillotineModels.Data.G2KP{D,S,P},Any,Dict{String,Any}}} where P where S where D","page":"PPG2KP","title":"GuillotineModels.build_model","text":"build_model(::Val{:G2CSP}, ::Val{:PPG2KP}, instance::G2KP, model[, options])\n\nBuild a PPG2KP-style model for a G2CSP instance inside model.\n\nChanges model by adding variables and constraints. options takes arguments described in Utilities.Args.accepted_arg_list(::Val{:PPG2KP}).\n\nThis is a convenience method that takes a G2KP instance. It allows easily testing G2CSP over the same instances used commonly for Knapsack Problem (G2KP). If options[\"quiet\"] is not passed, this method will always show a warnig, as the instance type is not ideal.\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP/#GuillotineModels.build_model-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{Val{:G2CSP},Val{:PPG2KP},GuillotineModels.Data.SSSCSP{D,S,P},Any}, Tuple{Val{:G2CSP},Val{:PPG2KP},GuillotineModels.Data.SSSCSP{D,S,P},Any,Dict{String,Any}}} where P where S where D","page":"PPG2KP","title":"GuillotineModels.build_model","text":"build_model(::Val{:G2CSP)}, ::Val{:PPG2KP}, instance::SSSCSP, model[, options])\n\nBuild a PPG2KP-style model for a G2CSP instance inside model.\n\nChanges model by adding variables and constraints. options takes arguments described in Utilities.Args.accepted_arg_list(::Val{:PPG2KP}).\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP/#GuillotineModels.build_model-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{Val{:G2KP},Val{:PPG2KP},GuillotineModels.Data.G2KP{D,S,P},Any}, Tuple{Val{:G2KP},Val{:PPG2KP},GuillotineModels.Data.G2KP{D,S,P},Any,Dict{String,Any}}} where P where S where D","page":"PPG2KP","title":"GuillotineModels.build_model","text":"build_model(::Val{:G2KP)}, ::Val{:PPG2KP}, instance::G2KP, model[, options])\n\nBuild a PPG2KP-style model for a G2KP instance inside model.\n\nChanges model by adding variables and constraints. options takes arguments described in Utilities.Args.accepted_arg_list(::Val{:PPG2KP}).\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP/#GuillotineModels.build_model-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{Val{:G2KP},Val{:PPG2KP},GuillotineModels.Data.SLOPP{D,S,P},Any}, Tuple{Val{:G2KP},Val{:PPG2KP},GuillotineModels.Data.SLOPP{D,S,P},Any,Dict{String,Any}}} where P where S where D","page":"PPG2KP","title":"GuillotineModels.build_model","text":"build_model(::Val{:G2KP}, ::Val{:PPG2KP}, instance::SLOPP, model[, options])\n\nBuild a PPG2KP-style model for a G2KP instance inside model.\n\nChanges model by adding variables and constraints. options takes arguments described in Utilities.Args.accepted_arg_list(::Val{:PPG2KP}).\n\nThis is a convenience method that takes a SLOPP instance. It errors if the SLOPP object has a non-zero value in the dlb field. It is the same as calling with a G2KP instance but with the dub field being used as the d field (of G2KP).\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP/#GuillotineModels.build_model-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{Val{:G2KP},Val{:PPG2KP},GuillotineModels.Data.SSSCSP{D,S,P},Any}, Tuple{Val{:G2KP},Val{:PPG2KP},GuillotineModels.Data.SSSCSP{D,S,P},Any,Dict{String,Any}}} where P where S where D","page":"PPG2KP","title":"GuillotineModels.build_model","text":"build_model(::Val{:G2KP}, ::Val{:PPG2KP}, instance::SSSCSP, model[, options])\n\nBuild a PPG2KP-style model for a G2OPP instance inside model.\n\nChanges model by adding variables and constraints. options takes arguments described in Utilities.Args.accepted_arg_list(::Val{:PPG2KP}).\n\nTHIS IS A HACK THAT SHOULD BE DELETED AFTER. It gets a SSSCSP instance, and does not interpret it as a G2CSP/G2BPP instance, but instead as a G2OPP instance and then it transforms it in a G2KP problem with unitaty profits, so the G2OPP (a decision problem) is true if obj matches the sum(d), and is false if obj is smaller than sum(d) (a value larger than sum(d) is impossible).\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP/#GuillotineModels.build_model-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{Val{:G2MKP},Val{:PPG2KP},GuillotineModels.Data.MHLOPPW{D,S,P},Any}, Tuple{Val{:G2MKP},Val{:PPG2KP},GuillotineModels.Data.MHLOPPW{D,S,P},Any,Dict{String,Any}}} where P where S where D","page":"PPG2KP","title":"GuillotineModels.build_model","text":"build_model(::Val{:G2MKP}, ::Val{:PPG2KP}, instance::MHLOPPW, model[, options])\n\nBuild a PPG2KP-style model for a G2MKP instance inside model.\n\nChanges model by adding variables and constraints. options takes arguments described in Utilities.Args.accepted_arg_list(::Val{:PPG2KP}).\n\nFor now, this is the only format accepted by G2MKP, even if the G2MKP refers to the homogeneous variant and, therefore, does not accept large objects of different dimensions (just multiple copies of the same large objects). A method accepting a more adequate format (i.e., that only allow a single type of large object) could be implemented.\n\n\n\n\n\n","category":"method"},{"location":"PPG2KP/#GuillotineModels.build_model-Union{Tuple{P}, Tuple{S}, Tuple{D}, Tuple{Val{:G2OPP},Val{:PPG2KP},GuillotineModels.Data.SSSCSP{D,S,P},Any}, Tuple{Val{:G2OPP},Val{:PPG2KP},GuillotineModels.Data.SSSCSP{D,S,P},Any,Dict{String,Any}}} where P where S where D","page":"PPG2KP","title":"GuillotineModels.build_model","text":"build_model(::Val{:G2OPP}, ::Val{:PPG2KP}, instance::SSSCSP, model[, options])\n\nBuild a PPG2KP-style model for a G2OPP instance inside model.\n\nChanges model by adding variables and constraints. options takes arguments described in Utilities.Args.accepted_arg_list(::Val{:PPG2KP}).\n\n\n\n\n\n","category":"method"},{"location":"#GuillotineModels.jl","page":"GuillotineModels","title":"GuillotineModels.jl","text":"","category":"section"},{"location":"","page":"GuillotineModels","title":"GuillotineModels","text":"The main utility of this package is to enable researchers to reproduce results for the FMT formulation from 10.1287/ijoc.2016.0710, and the enhanced formulation from https://arxiv.org/abs/2111.06348 (final link to be updated). This can be done without knowledge of julia programming by means of the script gmodels which is explained in the README.md. However, the package also makes available a trove of utility functions related to the solving of the G2KP and related problems (G2MKP, G2CSP, G2OPP). Here we give a short code walkthrough from someone interested in writing Julia code that makes use of the package functions directly.","category":"page"},{"location":"","page":"GuillotineModels","title":"GuillotineModels","text":"The code is divided into the following modules:","category":"page"},{"location":"","page":"GuillotineModels","title":"GuillotineModels","text":"GuillotineModels – The main module. The most important types and functions peratain to this module, and are fully described at the end of this page.\nGuillotineModels.CommandLine – The module used to implement the gmodels script, which is basically just a call to run. Most of the other functions in the module are only relevant to someone extending the run command. The only exception is round_instance which may be used to divide all values from a problem instance by some factor.\nGuillotineModels.CommandLine.SolversArgs – The module responsible for the interface between the rest of the code and GLPK.jl, CPLEX.jl, Gurobi.jl, and Cbc.jl. It only interests someone trying to extend the set of supported solvers.\nGuillotineModels.Utilities – The module aggregates the functions that are needed by one or more of other submodules but that do not are directly related to the package purpose. For example, relax! and restore! which help to change variables from binary/integer to continuous and back, or optimize_within_time_limit! which calls JuMP.optimize! but first checks for timeout and also changes the model object to respect the remaining time before timeout. The user may need to import the SortedLinkedLW if they want to work directly with GuillotineModels.PPG2KP.Enumeration.gen_cuts.\nGuillotineModels.Utilities.Args – The module implements the type Arg widely used in GuillotineModels.CommandLine to represent command-line options/flags. Necessary only for understanding how to extend GuillotineModels.CommandLine with more options.\nGuillotineModels.Data – Module responsible for all functions related to instance-reading. Useful for any user that intends to read the instances themselves, instead of relying on GuillotineModels.CommandLine.run. The multiple methods of function read_from_string are the most relevant contribution of the module. The read_from_file function is a convenience that just reads the whole content of a file and calls read_from_string over it. It also provides some limited instance writing capabilities.\nGuillotineModels.SaveModel – The module provides a function write_to_file that saves JuMP models to some file format. The module was developed because the MathOptInterface.write_to_file was inneficient when saving large models to MPS files. The GuillotineModels.SaveModel.write_to_file tries to call the annexed solver internal machinery to save the model to the desired format and, if this is not possible, it fallbacks to using the MathOptInterface method (which does not rely on the solver, but instead inspects the JuMP.model object and create the formatted output itself).\nGuillotineModels.PPG2KP – The module that implements the two formulations previously mentioned. For most users, the only interesting methods are the implementations of GuillotineModels.build_model for the formulations mentioned.\nGuillotineModels.PPG2KP.Heuristic – The module implements the 2-stage guillotine heuristic used in the pricing of 10.1287/ijoc.2016.0710 (the heuristic is first presented in 10.1016/j.cor.2010.12.018). The module can, therefore, be useful to an user interested in a simple heuristic for the G2KP for MIP-start, adding lower bound constraints, or gauging the quality of a model solution.\nGuillotineModels.PPG2KP.Enumeration – The module implements the plate enumeration needed by both mainly supported formulations. The module is of little interest for the average user, but gen_cuts may be used to directly generate the list of all plates, cuts, and piece extractions without needing to build the model itself.\nGuillotineModels.Flow{.Format,.Enumeration} – The submodule Flow and its submodules implement an unpublished formulation of little success. The module is kept for historical reasons. The only supported problem is G2KP and each component of an instance (lengths, widths, ...) needs to be given separatedely.","category":"page"},{"location":"","page":"GuillotineModels","title":"GuillotineModels","text":"To complement the walkthrough above, we also point out the small collection of code examples in the /examples folder of the GuillotineModels.jl package.","category":"page"},{"location":"","page":"GuillotineModels","title":"GuillotineModels","text":"create_and_solve_PPG2KP_model.jl – Create an FMT model (10.1287/ijoc.2016.0710) for a small instance and solve it, without using GuillotineModels.CommandLine.run.\ninstance_converter.jl – Example on how to extend GuillotineModels.Data.write_to_file. Reads a Classic_G2KP instance file and save it in the CPG_SLOPP format.\nrun_discretization.jl – Calls GuillotineModels.PPG2KP.Enumeration.gen_cuts directly and print some info about the descretization of a small instance.\nrun_heuristic.jl – Takes an instance in the Classic_G2KP format and run both the unoptimized and the optimized versions of the Guillotine 2-stage heuristic from GuillotineModels.PPG2KP.Heuristic over it. Shows the solution and the timings.","category":"page"},{"location":"","page":"GuillotineModels","title":"GuillotineModels","text":"For a better understanding on how to deal with already built models we suggest reviewing the JuMP documentation for version 0.21.5.","category":"page"},{"location":"","page":"GuillotineModels","title":"GuillotineModels","text":"The code heavily relies on parametric types, both for templated type and method signatures. Most of the cases, the type parameters are named D, S , P. The three are expected to be concrete subtypes of Integer. The D represents the type used to store piece demand (should be large enough to store the sum of all pieces demand). The S represents the type used to store the pieces size (should be enough to store the sum of all pieces length or width). The P represents the type used to store profit (or area, should be large enough to store the original plate area or the sum of all piece profits, whichever is the largest).","category":"page"},{"location":"","page":"GuillotineModels","title":"GuillotineModels","text":"CurrentModule = GuillotineModels","category":"page"},{"location":"","page":"GuillotineModels","title":"GuillotineModels","text":"Modules = [GuillotineModels]","category":"page"},{"location":"#GuillotineModels.GuillotineModels","page":"GuillotineModels","title":"GuillotineModels.GuillotineModels","text":"GuillotineModels is a collection of mathematical models for 2D Guillotine Cutting problems, all implemented using Julia+JuMP.\n\nIt was developed as part of the PhD thesis of Henrique Becker.\n\nThe main features are:\n\nThe implementation of distinct models using the same technology (Julia+JuMP) which is solver-agnostic.\nThe implementation of a CommandLine interface that make it easy to call the implemented models from the command-line to be solved by an specified solver, and also is extendable for new models and solvers.\n\n\n\n\n\n","category":"module"},{"location":"#GuillotineModels.CutPattern","page":"GuillotineModels","title":"GuillotineModels.CutPattern","text":"A guillotine stage-unlimited unrestricted cutting pattern.\n\nlength::Any\nThe length of the pattern.\nwidth::Any\nThe width of the pattern.\npiece_idx::Any\nIf the pattern represents a piece, then the piece index; otherwise zero.\ncuts_are_vertical::Bool\nThe common orientation of the cuts between the plates in subpatterns.\nsubpatterns::Array{CutPattern{D,S},1} where S where D\nThe subpatterns that constitute the pattern.\n\nNotes\n\ncuts_are_vertical is only relevant if subpatterns has length two or more.\nIf subpatterns is non-empty, and cuts_are_vertical == true, then the sum of the width of the patterns in subpatterns cannot be greater than width, and each individual length of a pattern in subpatterns cannot be greater than length. If cuts_are_vertical == false the same applies except length and width switch roles.\nIt is assumed that zero is not a valid piece index, as it is used in piece_idx to mark that a pattern is not sold as a piece (in this case, it is either a cut pattern or waste).\nIf piece_idx has a value different from zero, then subpatterns must be empty. In other words, a piece cannot be subdivided.\nWaste may be represented explicitly, by having plates with piece_idx == 0 but no elements in subpatterns, or implicitly, by having elements in subpatterns that do not fill all the area defined by length and width.\n\n\n\n\n\n","category":"type"},{"location":"#GuillotineModels.CutPattern-Union{Tuple{S}, Tuple{D}, Tuple{S,S,Bool,Array{CutPattern{D,S},1}}} where S where D","page":"GuillotineModels","title":"GuillotineModels.CutPattern","text":"CutPattern(length, width, cuts_are_vertical, subpatterns)\n\nSimplified constructor for intermediary plates.\n\n\n\n\n\n","category":"method"},{"location":"#GuillotineModels.CutPattern-Union{Tuple{S}, Tuple{D}, Tuple{S,S}, Tuple{S,S,D}} where S where D","page":"GuillotineModels","title":"GuillotineModels.CutPattern","text":"CutPattern(length, width, piece_idx)\n\nSimplified constructor for pieces and waste.\n\n\n\n\n\n","category":"method"},{"location":"#GuillotineModels.TimeoutError","page":"GuillotineModels","title":"GuillotineModels.TimeoutError","text":"TimeoutError <: Exception\n\nAn exception subtype representing a time limit not respected.\n\n\n\n\n\n","category":"type"},{"location":"#GuillotineModels.build_model","page":"GuillotineModels","title":"GuillotineModels.build_model","text":"build_model(problem, formulation, instance, model[, options])\n\nGiven an instance of problem, build formulation inside model.\n\nA dict of options that are problem- and formulation-specific may be also provided (otherwise defaults are used).\n\nShould always return two values: the first is always an element of BuildStopReason; the second is problem- and formulation-specific.\n\nArguments\n\nproblem: An object that identifies the problem being solved, e.g., Val(:G2KP). Each problem often requires a different instance type but sometimes an instance of a more general problem (that is not using the extra generality) may be passed to a more specific problem.\nformulation: An object that identifies the formulation used to model the problem, e.g., Val(:PPG2KP). Often same formulation can be adapted to multiple different problems with minimal changes.\ninstance: An object containing the problem data, e.g., G2KP or SLOPP.\nmodel: An object that behaves as a JuMP model, it will have variables and constraints added to it.\noptions::Dict{String, Any}: Problem- and formulation-specific options.\n\nReturns\n\n::BuildStopReason: The reason for which the method returned. It can be: BUILT_MODEL (the model was built successfully) or FOUND_OPTIMUM (in the process of building the model, the optimal solution was already found, so the building process was abandoned). See get_cut_pattern for more information.\n::Any: the specific type of the second returned value depends on the problem and formulation, however it should always exist (even if it is nothing). It is passed as an argument to get_cut_pattern in order to assemble a solution (CutPattern) from the variables values of a model.\n\n\n\n\n\n","category":"function"},{"location":"#GuillotineModels.get_cut_pattern","page":"GuillotineModels","title":"GuillotineModels.get_cut_pattern","text":"get_cut_pattern(problem, formulation, model, build_model_return)\n\nGiven a model built with build_model(problem, formulation, ...) and its respective build_model_return (i.e., the second return of build_model), returns a CutPattern representing the optimal solution found. If the first return of build_model is BUILT_MODEL, then the model needs to be solved before calling this method; however, if it is FOUND_OPTIMUM then the model does not need to be solved.\n\nThe implementation of this method is responsability of whoever implemented the corresponding build_model method.\n\nThe D and S type parameters from CutPattern{D, S} are inferred from build_model_return as of now.\n\nIf build_model returns nothing then model somehow needs to contain all information needed to build the CutPattern. Note that the problem instance (l, w, L, W, ...) is not passed to this method, consequently, a common pattern is to have build_model return a struct containing the problem instance and the auxiliary tables used to build the model (especially the ones associating variables with dimensions or piece indexes).\n\nThe solutions of some problems are not a single CutPattern but instead multiple CutPatterns inside an iterable collection of them (often a Vector).\n\nSee also: build_model\n\n\n\n\n\n","category":"function"},{"location":"#GuillotineModels.simplify!-Union{Tuple{CutPattern{D,S}}, Tuple{S}, Tuple{D}} where S where D","page":"GuillotineModels","title":"GuillotineModels.simplify!","text":"simplify!(p :: CutPattern{D, S}) :: CutPattern{D, S} where {D, S}\n\nThis method is free to make any changes while keeping all the packed pieces and the the validity of the solution, its purpose is to make the structure easier to understand by human beings. If you are trying to debug a model you will probably want to see both the simplified and not simplified output. The simplified will make it easier to understand the solution itself, and the non-simplified will show peculiarities that given insight on how the model works/'see things' internally.\n\nNOTE: the returned pattern is not always the given parameter, in some rare cases (a root plate with a single piece inside) the pattern returned may be another object.\n\nNOTE: this method does not create any new CutPattern objects but instead prunes and rearranges the pattern tree (i.e., throws away some objects and changes the position of others in the tree).\n\n\n\n\n\n","category":"method"},{"location":"#GuillotineModels.solution_value","page":"GuillotineModels","title":"GuillotineModels.solution_value","text":"solution_value(problem, instance, solution)\n\nReturn the value of solution for problem and instance.\n\nThe returned value is often an Int. If the solution (i) was extracted from a model with a valid primal solution and (ii) the model correctly computed the objective function, then the value returned by this function should match the value of the objective function in the model from which the solution was extracted. Basically, this function serves as a formulation-agnostic double-check of the obtained solution value.\n\nsolution is something returned by get_cut_pattern so often it is either a Vector{CutPattern{D, S}} or a single CutPattern{D, S}.\n\n!!! This function does not check the validity of the given solution, it assumes a valid solution and just compute the value it would have if it was valid.\n\n\n\n\n\n","category":"function"},{"location":"#GuillotineModels.throw_if_timeout-Tuple{Any,Any,Any}","page":"GuillotineModels","title":"GuillotineModels.throw_if_timeout","text":"throw_if_timeout(start, limit, now)\n\nThrows a TimeoutError if start - now > limit.\n\n\n\n\n\n","category":"method"},{"location":"#GuillotineModels.throw_if_timeout_now-Tuple{Any,Any}","page":"GuillotineModels","title":"GuillotineModels.throw_if_timeout_now","text":"throw_if_timeout_now(start, limit)\n\nThrows a TimeoutError if start - time() > limit.\n\n\n\n\n\n","category":"method"},{"location":"#GuillotineModels.to_pretty_str-Union{Tuple{CutPattern{D,S}}, Tuple{S}, Tuple{D}} where S where D","page":"GuillotineModels","title":"GuillotineModels.to_pretty_str","text":"to_pretty_str(p :: CutPattern{D, S}; kwargs...) :: String\n\nCreates a simplified and indented string representing the CutPattern.\n\nFormat\n\nThe format represents pieces as \"piece_idxplengthxwidth\" (e.g., \"1p10x20\" is a copy of piece 1 which have length 10 and width 20); non-piece patterns are represented by \"Plengthxwidth\" (note the P is uppercase); if the non-piece pattern has subpatterns (i.e., is not waste) then it starts a set of vertical (horizontal) cuts with [ ({) and close it with ] (}). There is always whitespace between the elements of such sets but, for conciseness and ease of reading, if all the elements of a subpattern have no children they are separated by single spaces (no matter how long the list), otherwise they are separated by newlines.\n\nKeyword Arguments\n\nlvl :: Int64: The current level of indentation.\nindent_str: The string or character to be repeated as indentation.\n\n\n\n\n\n","category":"method"},{"location":"#GuillotineModels.to_rectangles-Union{Tuple{CutPattern{D,S}}, Tuple{S}, Tuple{D}, Tuple{CutPattern{D,S},S}, Tuple{CutPattern{D,S},S,S}} where S where D","page":"GuillotineModels","title":"GuillotineModels.to_rectangles","text":"to_rectangles(p :: CutPattern{D, S}[, x, y])\n\nReturns a Vector with a normalized spatial positioning of pieces and plates.\n\nThe returned value is a Vector{Tuple{D, NTuple{4, S}}}, the first value is the piece/plate piece_idx, the second is a quadruplet (xo, yo, xf, yf) (i.e., the origins and the final coordinates in each dimension).\n\n\n\n\n\n","category":"method"},{"location":"#GuillotineModels.to_tikz_picture-Union{Tuple{CutPattern{D,S}}, Tuple{S}, Tuple{D}} where S where D","page":"GuillotineModels","title":"GuillotineModels.to_tikz_picture","text":"to_tikz_picture(p :: CutPattern{D, S}) :: String\n\nCreates a String with tikz code representing the CutPattern.\n\nThis is the same as to_tikz_rectangles but wraps the rectangles inside a \"\\begin{tikzpicture} ... \\end{tikzpicture}\" environment (i.e., the first and last lines are environment declarations).\n\n\n\n\n\n","category":"method"},{"location":"#GuillotineModels.to_tikz_rectangles-Union{Tuple{CutPattern{D,S}}, Tuple{S}, Tuple{D}} where S where D","page":"GuillotineModels","title":"GuillotineModels.to_tikz_rectangles","text":"to_tikz_rectangles(p :: CutPattern{D, S}) :: String\n\nCreates a String with tikz \\draw commands representing the CutPattern.\n\nThe tikz code has nodes indicating the piece indexes (waste pieces are not labeled because we do not distinguish between the waste pieces and the intermediary plates yet). The same node command is also outputted commented and with the size of piece, for easy alternance between these two informations.\n\n\n\n\n\n","category":"method"}]
}
